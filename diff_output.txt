--- index.html	2025-09-10 21:11:15.584942398 +0000
+++ narrative_quest_minibattle_gear_patched_FIXED.html	2025-09-10 21:11:15.584942398 +0000
@@ -34,35 +34,6 @@
             display: flex; align-items: center; justify-content: center;
             z-index: 100; pointer-events: all;
         }
-        #start-modal {
-            background: linear-gradient(120deg, #012534, #014f6b, #012534);
-            background-size: 200% 200%;
-            animation: oceanGradient 15s ease infinite;
-        }
-        #start-heading {
-            font-size: 3rem;
-            background: linear-gradient(90deg, #ffdd00, #ffa500, #ffdd00);
-            background-size: 200% 100%;
-            -webkit-background-clip: text;
-            -webkit-text-fill-color: transparent;
-            animation: shimmer 6s linear infinite;
-        }
-        #start-modal button {
-            transition: transform 0.3s, box-shadow 0.3s;
-            padding: 0.75rem 1.5rem;
-        }
-        #start-modal button:hover {
-            transform: scale(1.05);
-            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
-        }
-        @keyframes shimmer {
-            0% { background-position: 0% 50%; }
-            100% { background-position: 200% 50%; }
-        }
-        @keyframes oceanGradient {
-            0% { background-position: 0% 50%; }
-            100% { background-position: 100% 50%; }
-        }
         .modal-content {
             background-color: #fdf6e3; color: #3a2d21;
             padding: 1.5rem; border-radius: 10px; border: 4px solid #a87e3a;
@@ -251,11 +222,11 @@
     <!-- Start Modal -->
     <div id="start-modal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="start-heading">
         <div class="modal-content">
-            <h1 id="start-heading" class="mb-4 font-bold">üåä Welcome, Storyteller üåä</h1>
-            <p class="mb-6">Dive into the realm of legends. Will you forge a new path or continue your tale?</p>
-            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-2">
-                <button id="new-game-btn">‚ú® Forge New Legend</button>
-                <button id="continue-game-btn" disabled>‚è≥ Continue Journey</button>
+            <h1 id="start-heading" class="text-3xl mb-4">Welcome, Storyteller</h1>
+            <p class="mb-6">Your legend awaits. Will you forge a new path or continue an existing journey?</p>
+            <div class="flex flex-col sm:flex-row justify-center gap-4">
+                <button id="new-game-btn">Forge New Legend</button>
+                <button id="continue-game-btn" disabled>Continue Journey</button>
             </div>
         </div>
     </div>
@@ -462,11 +433,6 @@
         <div id="fisherman-name" class="npc-name">Fisherman</div>
         <div id="sage-name" class="npc-name">Sage of the Tides</div>
         <div id="war-torn-elder-name" class="npc-name">War-Torn Elder</div>
-        <div id="blacksmith-name" class="npc-name">Blacksmith</div>
-        <div id="merchant-name" class="npc-name">Merchant</div>
-        <div id="guard-name" class="npc-name">Guard</div>
-        <div id="innkeeper-name" class="npc-name">Innkeeper</div>
-        <div id="farmer-name" class="npc-name">Farmer</div>
 
         <div id="controls-info" aria-hidden="true">
             <b>Controls:</b><br><b>W, A, S, D:</b> Move<br><b>E:</b> Interact
@@ -797,157 +763,27 @@
         scene.add(dirLight);
 
         // Character factory
-        function createCharacterModel(skinColor = 0xffddbb, clothingColor = 0x888888) {
+        function createCharacterModel(color) {
             const group = new THREE.Group();
-
-            const bodyMat = new THREE.MeshStandardMaterial({ color: clothingColor });
-            const skinMat = new THREE.MeshStandardMaterial({ color: skinColor });
-
-            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.8, 1.6, 4, 8), bodyMat);
+            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.8, 1.6, 4, 8), new THREE.MeshStandardMaterial({ color }));
             body.castShadow = true; body.receiveShadow = true; body.position.y = 1.8; group.add(body);
-
-            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), skinMat.clone());
+            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshStandardMaterial({ color }));
             head.position.y = 3.5; head.castShadow = true; group.add(head);
-
-            // simple facial features
-            const eyeGeom = new THREE.SphereGeometry(0.1, 8, 8);
-            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
-            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
-            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
-            leftEye.position.set(-0.2, 0.1, 0.55);
-            rightEye.position.set(0.2, 0.1, 0.55);
-            head.add(leftEye); head.add(rightEye);
-            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.05), new THREE.MeshStandardMaterial({ color: 0x000000 }));
-            mouth.position.set(0, -0.2, 0.55); head.add(mouth);
-
-            // limbs
-            const armGeom = new THREE.BoxGeometry(0.2, 1.2, 0.2);
-            const legGeom = new THREE.BoxGeometry(0.3, 1.5, 0.3);
-            const leftArm = new THREE.Mesh(armGeom, clothingColor === skinColor ? skinMat.clone() : bodyMat.clone());
-            const rightArm = new THREE.Mesh(armGeom, clothingColor === skinColor ? skinMat.clone() : bodyMat.clone());
-            leftArm.position.set(-0.9, 1.2, 0);
-            rightArm.position.set(0.9, 1.2, 0);
-            const leftLeg = new THREE.Mesh(legGeom, bodyMat.clone());
-            const rightLeg = new THREE.Mesh(legGeom, bodyMat.clone());
-            leftLeg.position.set(-0.4, 0, 0);
-            rightLeg.position.set(0.4, 0, 0);
-            [leftArm, rightArm, leftLeg, rightLeg].forEach(l => { l.castShadow = true; group.add(l); });
-            group.userData = { arms: [leftArm, rightArm], legs: [leftLeg, rightLeg] };
-
-            return group;
-        }
-
-        function createAnimalModel(type) {
-            const group = new THREE.Group();
-            switch(type) {
-                case 'cow': {
-                    const body = new THREE.Mesh(new THREE.BoxGeometry(2,1,1), new THREE.MeshStandardMaterial({ color: 0x553322 }));
-                    body.position.y = 0.5; body.castShadow = true; group.add(body);
-                    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color: 0x553322 }));
-                    head.position.set(1.1,0.8,0); head.castShadow = true; group.add(head);
-                    break;
-                }
-                case 'chicken': {
-                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
-                    body.position.y = 0.5; body.castShadow = true; group.add(body);
-                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.2,8,8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
-                    head.position.set(0,0.9,0); head.castShadow = true; group.add(head);
-                    break;
-                }
-                case 'horse': {
-                    const body = new THREE.Mesh(new THREE.BoxGeometry(2,1,1), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
-                    body.position.y = 0.5; body.castShadow = true; group.add(body);
-                    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
-                    head.position.set(1.2,0.9,0); head.castShadow = true; group.add(head);
-                    break;
-                }
-                case 'sheep': {
-                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.8,16,16), new THREE.MeshStandardMaterial({ color: 0xffffff }));
-                    body.position.y = 0.8; body.castShadow = true; group.add(body);
-                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
-                    head.position.set(0.9,1,0); head.castShadow = true; group.add(head);
-                    break;
-                }
-            }
             return group;
         }
 
-        const wanderers = [];
-        function addWanderer(obj, radius) {
-            wanderers.push({ obj, radius, angle: Math.random() * Math.PI * 2, speed: Math.random() * 0.5 + 0.2, center: obj.position.clone() });
-        }
-
-        function animateLimbs(character, t) {
-            if (!character.userData || !character.userData.arms) return;
-            character.userData.arms[0].rotation.x = Math.sin(t) * 0.5;
-            character.userData.arms[1].rotation.x = -Math.sin(t) * 0.5;
-            character.userData.legs[0].rotation.x = -Math.sin(t) * 0.5;
-            character.userData.legs[1].rotation.x = Math.sin(t) * 0.5;
-        }
-
-        let encounterDistance = 0;
-
         // Player & NPCs
-        const player = createCharacterModel(0xffeecc, 0xffff00); player.position.set(0, 0, 20); scene.add(player);
-        const villageElder = createCharacterModel(0xffddbb, 0x0000ff); villageElder.position.set(0, 0, 0); villageElder.name = "Village Elder"; scene.add(villageElder);
-        const fisherman = createCharacterModel(0xffddbb, 0x808080); fisherman.position.set(-15, 0, -15); fisherman.name = "Fisherman"; scene.add(fisherman); addWanderer(fisherman, 6);
-        const sageOfTheTides = createCharacterModel(0xffddbb, 0x008080); sageOfTheTides.position.set(10, 0, -25); sageOfTheTides.name = "Sage of the Tides"; scene.add(sageOfTheTides); addWanderer(sageOfTheTides, 5);
-        const warTornElder = createCharacterModel(0xffddbb, 0x5a2e2e); warTornElder.position.set(-20, 0, 10); warTornElder.name = "War-Torn Elder"; scene.add(warTornElder); addWanderer(warTornElder, 4);
-        const blacksmith = createCharacterModel(0xffddbb, 0xff5500); blacksmith.position.set(15, 0, 5); blacksmith.name = "Blacksmith"; scene.add(blacksmith); addWanderer(blacksmith, 5);
-        const merchant = createCharacterModel(0xffddbb, 0x00aaff); merchant.position.set(-10, 0, 25); merchant.name = "Merchant"; scene.add(merchant); addWanderer(merchant, 7);
-        const guard = createCharacterModel(0xffddbb, 0x3333ff); guard.position.set(25, 0, 10); guard.name = "Guard"; scene.add(guard); addWanderer(guard, 6);
-        const innkeeper = createCharacterModel(0xffddbb, 0x964B00); innkeeper.position.set(5, 0, 25); innkeeper.name = "Innkeeper"; scene.add(innkeeper); addWanderer(innkeeper, 4);
-        const farmer = createCharacterModel(0xffddbb, 0x228B22); farmer.position.set(-25, 0, 5); farmer.name = "Farmer"; scene.add(farmer); addWanderer(farmer, 7);
-
-        const cow = createAnimalModel('cow'); cow.position.set(5, 0, -20); scene.add(cow); addWanderer(cow, 10);
-        const chicken = createAnimalModel('chicken'); chicken.position.set(-5, 0, 15); chicken.scale.set(0.5,0.5,0.5); scene.add(chicken); addWanderer(chicken, 8);
-        const horse = createAnimalModel('horse'); horse.position.set(20, 0, -15); scene.add(horse); addWanderer(horse, 6);
-        const sheep = createAnimalModel('sheep'); sheep.position.set(-22, 0, 12); scene.add(sheep); addWanderer(sheep, 9);
+        const player = createCharacterModel(0xffff00); player.position.set(0, 0, 20); scene.add(player);
+        const villageElder = createCharacterModel(0x0000ff); villageElder.position.set(0, 0, 0); villageElder.name = "Village Elder"; scene.add(villageElder);
+        const fisherman = createCharacterModel(0x808080); fisherman.position.set(-15, 0, -15); fisherman.name = "Fisherman"; scene.add(fisherman);
+        const sageOfTheTides = createCharacterModel(0x008080); sageOfTheTides.position.set(10, 0, -25); sageOfTheTides.name = "Sage of the Tides"; scene.add(sageOfTheTides);
+        const warTornElder = createCharacterModel(0x5a2e2e); warTornElder.position.set(-20, 0, 10); warTornElder.name = "War-Torn Elder"; scene.add(warTornElder);
 
         // Enemy (placeholder mesh)
         const pollutionElemental = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true }));
         pollutionElemental.position.set(-25, 2, 0); pollutionElemental.name = "Pollution Elemental"; pollutionElemental.castShadow = true; pollutionElemental.visible = false; scene.add(pollutionElemental);
         let createdMonster = { object: pollutionElemental, name: "Pollution Elemental", description: "a fearsome elemental born of plastic and sludge", baseHealth: 100 };
 
-        const monsters = [
-            { name: "Forest Spider", color: 0x444444, description: "a venomous forest spider", baseHealth: 80 },
-            { name: "Green Slime", color: 0x00ff00, description: "a quivering blob of ooze", baseHealth: 60 },
-            { name: "Goblin Scout", color: 0x006600, description: "a sneaky goblin scout", baseHealth: 90 }
-        ];
-        const dungeonMonsters = [
-            { name: "Skeleton Warrior", color: 0xffffff, description: "a rattling skeleton warrior", baseHealth: 120 },
-            { name: "Dark Knight", color: 0x222222, description: "an armored knight shrouded in darkness", baseHealth: 150 }
-        ];
-        const weapons = ["rusty sword", "iron axe", "oak bow", "steel dagger"];
-        let playerWeapon = weapons[Math.floor(Math.random()*weapons.length)];
-
-        function spawnRandomMonster(pool = monsters) {
-            const data = pool[Math.floor(Math.random() * pool.length)];
-            if (createdMonster.object) createdMonster.object.visible = false;
-            const geom = new THREE.IcosahedronGeometry(2, 0);
-            const mat = new THREE.MeshStandardMaterial({ color: data.color, flatShading: true });
-            const mesh = new THREE.Mesh(geom, mat);
-            mesh.position.copy(player.position).add(new THREE.Vector3(0, 2, -5));
-            mesh.castShadow = true; scene.add(mesh);
-            createdMonster = { object: mesh, name: data.name, description: data.description, baseHealth: data.baseHealth };
-            mesh.visible = false;
-        }
-
-        function triggerRandomEncounter(isDungeon=false) {
-            playerWeapon = weapons[Math.floor(Math.random()*weapons.length)];
-            spawnRandomMonster(isDungeon ? dungeonMonsters : monsters);
-            const prefix = isDungeon ? 'Dungeon' : 'Wild';
-            showMessage(`${prefix} ${createdMonster.name} appears!`);
-            messageButton.onclick = () => { hidePanel(messageBox); createdMonster.object.visible = true; startWritingCombat(); };
-        }
-
-        function checkDungeonEntrance() {
-            if (!inDungeon && player.position.distanceTo(dungeonEntrance.position) < 5) {
-                inDungeon = true;
-                triggerRandomEncounter(true);
-            }
-        }
-
         // World ground & road
         const groundGeometry = new THREE.PlaneGeometry(500, 500);
         const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4F7942 });
@@ -969,23 +805,6 @@
         const roadMaterial = new THREE.MeshStandardMaterial({ map: createGravelTexture() });
         const road = new THREE.Mesh(roadGeometry, roadMaterial); road.scale.y = 0.05; road.position.y = 0.1; road.receiveShadow = true; scene.add(road);
 
-        // Town buildings
-        function createBuilding(w, h, d, color, roofColor) {
-            const group = new THREE.Group();
-            const base = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color }));
-            base.castShadow = true; base.receiveShadow = true; group.add(base);
-            const roof = new THREE.Mesh(new THREE.ConeGeometry(w * 0.7, h * 0.5, 4), new THREE.MeshStandardMaterial({ color: roofColor }));
-            roof.position.y = h / 2 + h * 0.25; roof.rotation.y = Math.PI / 4; roof.castShadow = true; group.add(roof);
-            return group;
-        }
-        const house1 = createBuilding(6,4,6,0xb5651d,0x8b0000); house1.position.set(-12,0,8); scene.add(house1);
-        const shop = createBuilding(6,4,6,0x996633,0x555555); shop.position.set(12,0,-8); scene.add(shop);
-        const inn = createBuilding(8,5,8,0xcd853f,0x654321); inn.position.set(0,0,10); scene.add(inn);
-        const stable = createBuilding(5,3,7,0xdeb887,0x8b4513); stable.position.set(20,0,-12); scene.add(stable);
-        const dungeonEntrance = new THREE.Mesh(new THREE.CylinderGeometry(2,2,4,8,1,true), new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide }));
-        dungeonEntrance.position.set(30,2,-10); dungeonEntrance.castShadow = true; scene.add(dungeonEntrance);
-        let inDungeon = false;
-
         // Instanced trees, rocks
         const treeCount = 100;
         const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 8, 8);
@@ -1016,83 +835,6 @@
         }
         scene.add(instancedRocks);
 
-        // --- VILLAGE STRUCTURES ---
-
-        // Arrange houses in two neat rows north and south of the central square
-        const housePositions = [
-            [-10, 12], [0, 12], [10, 12],
-            [-10, -12], [0, -12], [10, -12]
-        ];
-        const houses = housePositions.map(([x, z]) => {
-            const house = createBuilding(6, 4, 6, 0x9b7653, 0x654321);
-            house.position.set(x, 0, z);
-            return house;
-        });
-        houses.forEach(h => scene.add(h));
-
-        // Central roads
-        function createRoad(x, z, width, height) {
-            const road = new THREE.Mesh(
-                new THREE.PlaneGeometry(width, height),
-                new THREE.MeshStandardMaterial({ color: 0x555555 })
-            );
-            road.rotation.x = -Math.PI / 2;
-            road.position.set(x, 0.01, z);
-            road.receiveShadow = true;
-            scene.add(road);
-            return road;
-        }
-        createRoad(0, 0, 40, 4);  // east-west road
-        createRoad(0, 0, 4, 40);  // north-south road
-
-        // Perimeter fencing
-        const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
-        const fenceRadius = 25;
-        const fenceStep = Math.PI / 8;
-        const railLength = 2 * fenceRadius * Math.sin(fenceStep / 2);
-        for (let angle = 0; angle < Math.PI * 2; angle += fenceStep) {
-            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2, 6), fenceMaterial);
-            post.position.set(Math.cos(angle) * fenceRadius, 1, Math.sin(angle) * fenceRadius);
-            post.castShadow = true; scene.add(post);
-
-            const midAngle = angle + fenceStep / 2;
-            const rail = new THREE.Mesh(new THREE.BoxGeometry(railLength, 0.2, 0.2), fenceMaterial);
-            rail.position.set(Math.cos(midAngle) * fenceRadius, 1.2, Math.sin(midAngle) * fenceRadius);
-            rail.rotation.y = midAngle + Math.PI / 2;
-            rail.castShadow = true; scene.add(rail);
-        }
-
-        // Market stalls
-        function createStall(x, z) {
-            const stall = new THREE.Group();
-            const counter = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 2), new THREE.MeshStandardMaterial({ color: 0xdeb887 }));
-            counter.position.y = 0.5; counter.castShadow = true; counter.receiveShadow = true; stall.add(counter);
-            const canopy = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.2, 2.5), new THREE.MeshStandardMaterial({ color: 0xffe4b5 }));
-            canopy.position.y = 2; canopy.castShadow = true; stall.add(canopy);
-            const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 2, 6);
-            const polePositions = [ [-2, -1], [2, -1], [-2, 1], [2, 1] ];
-            polePositions.forEach(([px, pz]) => {
-                const pole = new THREE.Mesh(poleGeom, fenceMaterial);
-                pole.position.set(px, 1, pz); pole.castShadow = true; stall.add(pole);
-            });
-            stall.position.set(x, 0, z);
-            return stall;
-        }
-        const stalls = [createStall(8, 0), createStall(-8, 0)];
-        stalls.forEach(s => scene.add(s));
-
-        // Village well
-        const well = new THREE.Group();
-        const wellBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 2, 16), new THREE.MeshStandardMaterial({ color: 0x808080 }));
-        wellBase.position.y = 1; wellBase.castShadow = true; wellBase.receiveShadow = true; well.add(wellBase);
-        const wellRoof = new THREE.Mesh(new THREE.ConeGeometry(2.5, 2, 4), new THREE.MeshStandardMaterial({ color: 0x654321 }));
-        wellRoof.position.y = 3; wellRoof.rotation.y = Math.PI / 4; wellRoof.castShadow = true; well.add(wellRoof);
-        well.position.set(0, 0, 0); scene.add(well);
-
-        // Farmland patch
-        const farm = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
-        farm.rotation.x = -Math.PI / 2; farm.position.set(20, 0, 0); farm.receiveShadow = true; scene.add(farm);
-
         // Ambient particles
         const particleCount = 500;
         const particlesGeometry = new THREE.BufferGeometry();
@@ -1622,15 +1364,15 @@
             gameState.isCombatActive = true; canMove = false;
             combatState.playerHP = playerStats.baseHealth; combatState.enemyHP = createdMonster.baseHealth; combatState.isPlayerTurn = true;
             combatTitle.textContent = `Battle with ${createdMonster.name}!`;
-            combatLog.innerHTML = `You brandish your ${playerWeapon} as ${createdMonster.name} approaches! ${createdMonster.description}.<br>`;
+            combatLog.innerHTML = `A wild ${createdMonster.name} appears! ${createdMonster.description}.<br>`;
             updateCombatUI(); nextCombatTurn(); showPanel(combatPanel, combatWritingInput);
         }
         function nextCombatTurn() {
             if (!gameState.isCombatActive) return;
             if (combatState.isPlayerTurn) {
                 combatSubmitBtn.disabled=false; combatWritingInput.disabled=false;
-                if (combatState.useSpecialMove) { combatPrompt.textContent = `Use a simile to describe your ${playerWeapon} attack!`; combatWritingInput.placeholder = "e.g., My strike is like lightning..."; }
-                else { combatPrompt.textContent = `The creature waits. Describe how you wield your ${playerWeapon}!`; combatWritingInput.placeholder = "e.g., I unleash a torrent of water..."; }
+                if (combatState.useSpecialMove) { combatPrompt.textContent = "Use a simile to describe your attack!"; combatWritingInput.placeholder = "e.g., My strike is like lightning..."; }
+                else { combatPrompt.textContent = "The creature waits. Describe your attack!"; combatWritingInput.placeholder = "e.g., I unleash a torrent of water..."; }
                 combatWritingInput.focus();
             } else {
                 combatSubmitBtn.disabled=true; combatWritingInput.disabled=true; combatPrompt.textContent = "Enemy is attacking..."; setTimeout(enemyTurn, 1500);
@@ -1833,13 +1575,6 @@
                 mesh.position.y = mesh.userData.baseY + Math.sin(elapsed * 2 + mesh.position.x) * 0.25;
             });
 
-            wanderers.forEach(w => {
-                w.angle += delta * w.speed;
-                w.obj.position.x = w.center.x + Math.cos(w.angle) * w.radius;
-                w.obj.position.z = w.center.z + Math.sin(w.angle) * w.radius;
-                animateLimbs(w.obj, elapsed * 5 + w.angle);
-            });
-
             if (!gameStarted) { renderer.render(scene, camera); return; }
 
             if (canMove) {
@@ -1848,28 +1583,16 @@
                 if (moveBackward) dir.z += 1;
                 if (moveLeft) dir.x -= 1;
                 if (moveRight) dir.x += 1;
-                if (dir.lengthSq() > 0) {
-                    dir.normalize().multiplyScalar(moveSpeed * delta);
-                    player.position.add(dir);
-                    animateLimbs(player, elapsed * 5);
-                    encounterDistance += dir.length();
-                    if (encounterDistance > 20 && Math.random() < 0.05) { encounterDistance = 0; triggerRandomEncounter(); }
-                } else {
-                    animateLimbs(player, 0);
-                }
-            } else {
-                animateLimbs(player, 0);
+                if (dir.lengthSq() > 0) { dir.normalize().multiplyScalar(moveSpeed * delta); player.position.add(dir); }
             }
 
-            checkDungeonEntrance();
-
             camera.position.x = player.position.x;
             camera.position.z = player.position.z + 50;
             camera.lookAt(player.position);
 
             // Interactibles
             let closeInteractable = null;
-            const npcs = [villageElder, fisherman, sageOfTheTides, warTornElder, blacksmith, merchant, guard, innkeeper, farmer];
+            const npcs = [villageElder, fisherman, sageOfTheTides, warTornElder];
             npcs.forEach(npc => { const d = player.position.distanceTo(npc.position); if (d < 5) closeInteractable = npc.name; });
             memoryFragmentMeshes.forEach((m, i) => { if (m.visible && player.position.distanceTo(m.position) < 2.5) closeInteractable = { type:'fragment', index:i }; });
 
@@ -1886,11 +1609,6 @@
                 { obj: fisherman, el: document.getElementById('fisherman-name') },
                 { obj: sageOfTheTides, el: document.getElementById('sage-name') },
                 { obj: warTornElder, el: document.getElementById('war-torn-elder-name') },
-                { obj: blacksmith, el: document.getElementById('blacksmith-name') },
-                { obj: merchant, el: document.getElementById('merchant-name') },
-                { obj: guard, el: document.getElementById('guard-name') },
-                { obj: innkeeper, el: document.getElementById('innkeeper-name') },
-                { obj: farmer, el: document.getElementById('farmer-name') },
             ];
             if (!canMove) { npcs.forEach(n=> n.el.style.display='none'); return; }
             npcs.forEach(n => {
