<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Narrative Quest</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Lora', serif;
            background-color: #000;
            color: white;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #3a2d21;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(253, 246, 227, 0.9);
            border: 4px solid #a87e3a;
            border-radius: 8px;
            padding: 1rem; /* Use rem for consistent scaling */
            pointer-events: all;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-height: 90vh;
            overflow-y: auto;
            max-width: 90%;
            width: auto;
            min-width: 250px;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }
        .modal-content {
            background-color: #fdf6e3;
            color: #3a2d21;
            padding: 2rem; /* Increased padding for better touch targets */
            border-radius: 10px;
            border: 4px solid #a87e3a;
            width: 90%;
            max-width: 700px;
            text-align: center;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }
        .modal-scroll-content {
            overflow-y: auto;
            padding-right: 15px;
        }
        .creator-option {
            border: 2px solid #d4cba6;
            cursor: pointer;
            padding: 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
            background-color: #fff;
            height: 100%;
            min-height: 90px; /* Adjusted size */
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .creator-option:hover {
            background-color: #f0e5c6;
        }
        .creator-option.selected {
            border-color: #00796b;
            background-color: #e0f2f1;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 121, 107, 0.5);
        }
        #custom-guardian-input {
            display: none;
            margin-top: 10px;
            padding: 10px;
            width: 100%;
            border: 2px solid #a87e3a;
            border-radius: 5px;
            font-family: 'Lora', serif;
        }
        #quest-log {
            top: 1rem;
            left: 1rem;
            width: 250px;
            transition: all 0.3s ease;
        }
        #quest-log.minimized {
            width: auto;
            padding: 0.5rem 1rem;
            padding-right: 2rem;
        }
        #quest-log.minimized h1 {
            font-size: 1.2rem;
            margin-bottom: 0;
        }
        #quest-log p {
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        #quest-log.minimized #quest-log-content {
            display: none;
        }
        .xp-bar-container {
            background-color: #d4cba6;
            border-radius: 9999px;
            overflow: hidden;
            border: 2px solid #a87e3a;
            padding: 2px;
            margin-top: 5px;
        }
        .xp-bar {
            background: linear-gradient(90deg, #c89c4a, #f7e08b);
            height: 10px;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
        }
        .minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            padding: 0;
            font-size: 1.2rem;
            line-height: 24px;
            text-align: center;
            margin-top: 0;
            font-family: monospace;
            cursor: pointer;
        }
        #dialogue-box {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            min-height: 100px;
            display: none;
        }
        #writing-challenge, #dynamic-quest-creator, #quest-complete, #journal-panel, #monster-created-panel, #combat-panel, #message-box {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            display: none;
        }
        #writing-tips-box {
            background: #e0f2f1; /* Light teal, matching other UI hints */
            border-left: 4px solid #00796b; /* Accent border */
            padding: 10px;
            margin-top: 15px;
            margin-bottom: 15px; /* Add some space before the textarea */
            text-align: left;
            border-radius: 4px; /* Slightly rounded corners */
        }
        #writing-tips-box h3 {
             font-family: 'MedievalSharp', cursive;
             color: #004d40; /* Darker teal for the heading */
             margin-bottom: 5px;
        }
        #combat-panel {
            text-align: center;
        }
        #combat-log {
            background-color: #fff;
            border: 2px solid #d4cba6;
            height: 120px;
            overflow-y: scroll;
            padding: 10px;
            margin-top: 15px;
            text-align: left;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        #improvement-suggestion {
            background: #fff;
            border: 2px solid #d4cba6;
            padding: 15px;
            margin-top: 15px;
            text-align: left;
            border-radius: 8px;
        }
        #journal-entries, #achievements-list {
            text-align: left;
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #d4cba6;
            min-height: 200px;
            max-height: 40vh;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .journal-entry {
            background-color: #f8f0e0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #d4cba6;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }
        .journal-entry:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .journal-entry h3, .achievement h3 {
            font-family: 'MedievalSharp', cursive;
            color: #a87e3a;
            margin-bottom: 5px;
        }
        .journal-stage {
            font-size: 0.9em;
            color: #5d4037;
            font-style: italic;
            margin-bottom: 5px;
        }
        .journal-entry button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #00796b;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            display: none;
            cursor: pointer;
        }
        .journal-entry:hover button {
            display: block;
        }
        .achievement {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 2px solid #d4cba6;
        }
        .achievement.unlocked {
            background-color: #e0f2f1;
        }
        .achievement.locked {
            background-color: #f1f1f1;
            color: #999;
        }
        .achievement p {
            font-size: 0.9em;
        }
        .journal-tabs {
            display: flex;
            margin-bottom: -2px; /* Overlap border */
        }
        .journal-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #d4cba6;
            border: 2px solid #a87e3a;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            margin-right: 5px;
        }
        .journal-tab.active {
            background-color: #fff;
            border-bottom: 2px solid #fff;
        }
        #achievement-notification {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #c89c4a;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-family: 'MedievalSharp', cursive;
            font-size: 1.3rem;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
            pointer-events: none;
        }
        #interact-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.5rem;
            font-family: 'MedievalSharp', cursive;
            display: none;
        }
        #loading-message {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2rem;
            display: none;
        }
        #autosave-notification {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        h1, h2, h3 {
            font-family: 'MedievalSharp', cursive;
        }
        h1 { font-size: 1.8rem; color: #a87e3a; }
        h2 { font-size: 1.4rem; }
        textarea, input[type="text"] {
            width: 100%;
            background-color: #fff;
            border: 2px solid #d4cba6;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Lora', serif;
            color: #3a2d21;
        }
        textarea { height: 150px; }
        button {
            background-color: #c89c4a;
            color: white;
            padding: 1rem 1.5rem; /* Increased padding for better touch targets */
            border: none;
            border-radius: 5px;
            font-family: 'MedievalSharp', cursive;
            font-size: 1.2rem;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #a87e3a;
        }
        button:disabled {
            background-color: #888;
            cursor: not-allowed;
        }
        #controls-info {
            position: absolute;
            bottom: 1rem;
            left: 1rem; /* Moved to the left */
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 0.9rem;
        }
        #feedback-area {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            min-height: 24px;
        }
        .feedback-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .health-bar-container {
            background-color: #d4cba6;
            border-radius: 9999px;
            overflow: hidden;
            border: 2px solid #a87e3a;
            padding: 2px;
            margin: 0 auto;
            width: 80%;
        }
        .health-bar {
            background: linear-gradient(90deg, #d9534f, #f7d58b);
            height: 10px;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
        }
        .health-bar.player {
            background: linear-gradient(90deg, #5cb85c, #90ee90);
        }
        .npc-name {
            position: absolute;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            text-align: center;
            transform: translate(-50%, -50%);
            pointer-events: none;
            white-space: nowrap;
            display: none;
        }
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fdf6e3;
            color: #3a2d21;
            padding: 20px;
            border: 4px solid #a87e3a;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
            text-align: center;
            pointer-events: all;
        }
        .tts-loading-indicator {
            display: inline-block;
            width: 15px;
            height: 15px;
            border: 2px solid #c89c4a;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.2rem; }
            .ui-panel {
                padding: 1rem;
            }
            button {
                padding: 0.8rem 1.2rem;
                font-size: 1rem;
            }
            .creator-option {
                min-height: 80px; /* Adjusted size for mobile */
            }
            #controls-info, #autosave-notification {
                display: none; /* Hide on smaller screens to save space */
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Lora:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-modal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="start-heading">
        <div class="modal-content">
            <h1 id="start-heading" class="text-3xl mb-4">Welcome, Storyteller</h1>
            <p class="mb-6">Your legend awaits. Will you forge a new path or continue an existing journey?</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <button id="new-game-btn">Forge New Legend</button>
                <button id="continue-game-btn" disabled>Continue Journey</button>
            </div>
        </div>
    </div>

    <div id="character-creator" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="creator-heading" style="display: none;">
        <div class="modal-content">
            <div class="modal-scroll-content">
                <h1 id="creator-heading" class="text-3xl mb-4">Forge Your Hero</h1>
                <p class="mb-6">Every story needs a beginning. Who is yours?</p>
                
                <div class="mb-6 text-left">
                    <h2 class="text-xl mb-2">Choose Your Guardian Type</h2>
                    <div id="guardian-type-options" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="creator-option" data-type="Shark Guardian" role="button" tabindex="0">
                            <div class="text-2xl mb-1">ü¶à</div>
                            <div class="font-bold">Shark Guardian</div>
                            <p class="text-xs">A mighty warrior, clad in coral armor, a stalwart defender of the vibrant reefs.</p>
                        </div>
                        <div class="creator-option" data-type="Jellyfish Guardian" role="button" tabindex="0">
                            <div class="text-2xl mb-1">‚ú®</div>
                            <div class="font-bold">Jellyfish Guardian</div>
                            <p class="text-xs">A mystical being of light and water, who commands the deep ocean currents.</p>
                        </div>
                        <div class="creator-option" data-type="Manta Ray Guardian" role="button" tabindex="0">
                            <div class="text-2xl mb-1">üåä</div>
                            <div class="font-bold">Manta Ray Guardian</div>
                            <p class="text-xs">A silent hunter and graceful navigator of the vast and open blue.</p>
                        </div>
                        <div class="creator-option" data-type="custom" role="button" tabindex="0">
                            <div class="text-2xl mb-1">‚úèÔ∏è</div>
                            <div class="font-bold">My Own Guardian</div>
                            <p class="text-xs">Bring your own legend to life. Describe a hero from your imagination.</p>
                        </div>
                    </div>
                    <input type="text" id="custom-guardian-input" placeholder="e.g., Sea Turtle, Octopus...">
                </div>

                <div class="mb-6 text-left">
                    <h2 class="text-xl mb-2">Choose Your Realm</h2>
                    <div id="guardian-domain-options" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="creator-option" data-domain="Coral Reef" role="button" tabindex="0">
                            <div class="text-2xl mb-1">üê†</div>
                            <p class="text-xs">Coral Reef</p>
                        </div>
                        <div class="creator-option" data-domain="Deep Trench" role="button" tabindex="0">
                            <div class="text-2xl mb-1">ü¶ë</div>
                            <p class="text-xs">Deep Trench</p>
                        </div>
                        <div class="creator-option" data-domain="Kelp Forest" role="button" tabindex="0">
                            <div class="text-2xl mb-1">üåø</div>
                            <p class="text-xs">Kelp Forest</p>
                        </div>
                    </div>
                </div>
            </div>
            <button id="start-game-btn" class="mt-4">Begin Your Legend</button>
        </div>
    </div>

    <div id="ui-container" style="visibility: hidden;">
        <div id="quest-log" class="ui-panel" role="region" aria-labelledby="quest-heading">
            <button id="minimize-quest-log" class="minimize-btn" aria-label="Minimize quest log">-</button>
            <h1 id="quest-heading">Quest Log</h1>
            <div id="quest-log-content">
                <p id="player-level-info" class="font-bold">Level 1 Guardian</p>
                <div class="xp-bar-container">
                    <div id="xp-bar" class="xp-bar"></div>
                </div>
                <p class="mt-2 text-sm">Attack: <span id="player-attack"></span></p>
                <p class="text-sm">Health: <span id="player-health"></span></p>
                <p id="quest-title" class="mt-4">No active quest.</p>
                <p id="quest-objective">The Village Elder seems troubled. Perhaps they have a story to tell.</p>
                <div class="flex flex-col gap-2 mt-4">
                    <button id="open-journal-btn" class="text-sm p-1">Open Journal</button>
                    <button id="save-game-btn" class="text-sm p-1">Save Game</button>
                </div>
            </div>
        </div>

        <div id="dialogue-box" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="dialogue-title">
            <h2 id="dialogue-title">Village Elder</h2>
            <p id="dialogue-text">Welcome, hero. A shadow has fallen upon our waters, and we need your strength.</p>
            <div class="flex justify-center">
                 <button id="dialogue-button">Accept Quest</button>
            </div>
        </div>

        <div id="writing-challenge" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="challenge-title">
            <h2 id="narrative-stage"></h2>
            <h3 id="challenge-title">Challenge: Loading...</h3>
            <p id="challenge-prompt">Loading...</p>
            <div id="writing-tips-box" style="display: none;" role="region" aria-labelledby="tips-heading">
                <h3 id="tips-heading" class="text-lg font-bold">Writing Tips</h3>
                <p id="current-tips"></p>
            </div>
            <textarea id="writing-input" placeholder="My Guardian is a warrior of the deep, clad in armor of coral..."></textarea>
            <div id="feedback-area" aria-live="polite"></div>
            <button id="writing-submit">Weave Your Tale</button>
        </div>

        <div id="dynamic-quest-creator" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="dynamic-quest-heading">
            <h1 id="dynamic-quest-heading" class="text-2xl">The Storyteller's Choice</h1>
            <p class="my-4">Your description of the spreading sickness has revealed the true nature of the threat. The story is now in your hands. In a short paragraph, describe what happens next. Do you discover a great beast? A cursed artifact? A hidden villain? Write the next chapter.</p>
            <textarea id="dynamic-quest-input" placeholder="As the oily slick parts, a colossal shape begins to rise from the depths..."></textarea>
            <button id="dynamic-quest-submit">Shape the Climax</button>
        </div>
        
        <div id="monster-created-panel" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="monster-heading" style="display: none;">
            <div class="modal-content text-center">
                <h1 id="monster-heading" class="text-3xl mb-4 text-red-600">From your words, a challenge emerges...</h1>
                <p class="mb-6">Your description has summoned a new foe to the surface!</p>

                <div class="p-6 rounded-lg border-2 border-red-800 bg-red-50 mb-6">
                    <h2 id="monster-name" class="text-2xl font-bold my-2 text-red-800"></h2>
                    <p id="monster-description" class="my-4 text-red-700"></p>
                </div>
                
                <button id="start-combat-btn" class="bg-red-500 hover:bg-red-700">Continue</button>
            </div>
        </div>

        <div id="quest-complete" class="ui-panel text-center" role="dialog" aria-modal="true" aria-labelledby="quest-complete-heading">
            <h1 id="quest-complete-heading" class="text-2xl text-green-600">A Chapter Closes</h1>
            <p id="reward-text" class="my-4 text-lg"></p>
            <div id="improvement-suggestion">
            </div>
            <div class="flex justify-center gap-4 flex-wrap">
                <button id="try-again-btn">Try Again Myself</button>
                <button id="continue-questing-btn">Continue Questing</button>
            </div>
        </div>
        
        <div id="combat-panel" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="combat-title">
            <h2 id="combat-title"></h2>
            <p class="mt-4">Your Health:</p>
            <div class="health-bar-container" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" aria-label="Player health">
                <div id="player-health-bar" class="health-bar player"></div>
            </div>
            <p class="mt-2">Enemy Health:</p>
            <div class="health-bar-container" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" aria-label="Enemy health">
                <div id="enemy-health-bar" class="health-bar"></div>
            </div>
            <div id="combat-log" class="mt-4"></div>
            <p id="combat-prompt" class="mt-4 font-bold"></p>
            <div class="flex gap-2 mt-2">
                <input type="text" id="combat-writing-input" class="flex-grow" placeholder="Describe your action...">
                <button id="combat-submit-btn" class="p-2 text-base">Attack!</button>
            </div>
            <button id="special-move-btn" class="mt-2 text-sm p-1 bg-purple-600 hover:bg-purple-800">Use Simile (Lvl 2)</button>
        </div>


        <div id="journal-panel" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="journal-heading">
            <h1 id="journal-heading" class="text-2xl">Story Journal</h1>
            <div class="journal-tabs">
                <div id="story-tab" class="journal-tab active">Story</div>
                <div id="achievements-tab" class="journal-tab">Achievements</div>
            </div>
            <div id="journal-entries"></div>
            <div id="achievements-list" style="display: none;"></div>
            <div class="flex justify-center gap-4 mt-4">
                <button id="copy-journal-btn">Copy Story</button>
                <button id="close-journal-btn">Close</button>
            </div>
        </div>
        
        <div id="interact-prompt" aria-hidden="true">Press [E] to Interact</div>
        <div id="loading-message" role="status" aria-live="polite">The world holds its breath...</div>
        
        <div id="elder-name" class="npc-name">Village Elder</div>
        <div id="fisherman-name" class="npc-name">Fisherman</div>
        <div id="sage-name" class="npc-name">Sage of the Tides</div>
        <div id="war-torn-elder-name" class="npc-name">War-Torn Elder</div>


        <div id="controls-info" aria-hidden="true">
            <b>Controls:</b><br>
            <b>W, A, S, D:</b> Move<br>
            <b>E:</b> Interact
        </div>
        <div id="autosave-notification">Auto-saving...</div>
        <div id="achievement-notification">Achievement Unlocked!</div>
    </div>
    
    <div id="message-box" class="ui-panel" role="alertdialog" aria-modal="true" aria-labelledby="message-text">
        <p id="message-text">Message goes here.</p>
        <button id="message-button">OK</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        
        // --- GEMINI API SETUP ---
        const LLM_API_URL = '/api/gemini';
        const TTS_API_URL = '/api/gemini-tts';

        // --- GAME STATE & CHARACTER DATA ---
        let characterData = {
            type: null,
            domain: null,
            customName: ""
        };
        
        let playerStats = {
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            baseHealth: 100,
            baseDamage: 10,
            journal: [],
            achievements: {},
            collectedFragments: 0
        };
        
        let lastSubmission = "";
        let lastValidationResponse = null;
        let currentMonsterName = "";
        let currentMonsterDescription = "";
        let currentMonsterHealth = 100;
        
        // --- World Atmosphere Transition ---
        let isTransitioningAtmosphere = false;
        let atmosphereTransitionDuration = 4000; // 4 seconds
        let atmosphereTransitionStart = 0;
        const startAtmo = {};
        const targetAtmo = {};


        const narrativeStages = ["Exposition", "Rising Action", "Climax", "Falling Action", "Resolution"];
        const writingTips = {
            "Exposition": "Focus on characters and setting. Introduce your hero and their world. Show, don't tell.",
            "Rising Action": "Build tension and excitement. Add challenges and obstacles that get progressively harder. Use a 'cause and effect' structure.",
            "Climax": "Write the most intense moment of your story. Use short, powerful sentences to describe the biggest confrontation.",
            "Falling Action": "Calm things down. Show the immediate consequences of the climax and tie up any loose ends.",
            "Resolution": "Bring your story to a satisfying close. Describe the new normal and show how your character has changed."
        };
        
        const achievements = {
            "STORY_BEGINS": { title: "The Story Begins", description: "Complete your first writing challenge.", unlocked: false },
            "FIRST_VICTORY": { title: "First Victory", description: "Win your first narrative combat.", unlocked: false },
            "LOREMASTER": { title: "Loremaster", description: "Collect all the memory fragments.", unlocked: false },
            "WORD_WEAVER": { title: "Word Weaver", description: "Successfully use a special move in combat.", unlocked: false },
            "SAVIOR": { title: "Savior of the Lands", description: "Complete all quests.", unlocked: false }
        };

        const memoryFragments = [
            { pos: new THREE.Vector3(15, 2, 15), text: "Lore: The ancient stones whisper of a time when the sky and sea were one, before the Great Separation.", collected: false },
            { pos: new THREE.Vector3(-10, 2, -20), text: "Writing Tip: Use strong verbs to make your actions more impactful! Instead of 'walked,' try 'stomped,' 'glided,' or 'crept.'", collected: false },
            { pos: new THREE.Vector3(20, 2, -10), text: "Lore: It is said the first Guardian was born from a tear of the ocean itself, a being of pure will.", collected: false },
            { pos: new THREE.Vector3(-25, 2, 25), text: "Writing Tip: Sensory details bring a world to life. What does the air smell like? What sounds can you hear?", collected: false },
        ];
        
        let memoryFragmentMeshes = [];

        // ===== Classroom Safety Config (tweak to taste) =====
        const SAFETY = {
            maxViolence: 1, // 0 none, 1 mild/cartoon allowed; block 2+ (moderate/graphic)
            maxGore: 1,     // block 2+ (blood/injury described), 3=graphic gore
            slangPolicy: "nudge", // "nudge" or "block" for slang/brain-rot
        };

        // Quick denylist (fast local catch before calling Gemini)
        const DENYLIST = [
            /\b(?:nigg\w+)\b/i,               // racial slur
            /\b(?:suicide|kill myself)\b/i,    // self-harm
            /\b(?:address\s*\d{2,}|phone\s*\d{6,})\b/i // PII-ish
        ];

        // Helper function for TTS audio
        const pcmToWav = (pcmData, sampleRate) => {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;

            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);

            // RIFF chunk
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true); // bits per sample

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);

            // Write PCM data
            new Int16Array(buffer, 44).set(pcmData);

            return new Blob([view], { type: 'audio/wav' });
        };

        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };


        async function callProxyAPI(apiUrl, payload) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
        
                // Read the body ONCE, regardless of the response status.
                // This works because both successful responses and Vercel's error responses are typically JSON.
                const data = await response.json();
        
                // Now, check if the response was not successful.
                if (!response.ok) {
                    console.error("API call via proxy failed:", response.status, data);
                    if (response.status === 500 && data.error && data.error.includes("API key not configured")) {
                        showMessage("The game's AI features are not configured on the server. Please contact the administrator.");
                    }
                    return null;
                }
        
                // Handle safety checks from a successful response
                if (data.candidates && data.candidates[0].finishReason === 'SAFETY') {
                    showMessage("Your writing was blocked for safety reasons. Please revise and try again.");
                    return null;
                }
        
                return data; // Return the successfully read and checked data.
        
            } catch (error) {
                // This catch block now handles network errors or if the response body is not valid JSON.
                console.error("Error calling proxy API:", error);
                if (error instanceof TypeError && error.message.includes('Failed to parse URL')) {
                     showMessage("The AI features require this game to be run on a web server. Local testing of this feature is not supported.");
                } else {
                     showMessage("A network error occurred. Please check your connection and try again.");
                }
                return null;
            }
        }
        
        async function callGeminiForText(systemPrompt, userPrompt, schema) {
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: schema
                }
            };
        
            const result = await callProxyAPI(LLM_API_URL, payload);
            if (!result || !result.candidates || !result.candidates[0].content) {
                return null;
            }
        
            try {
                const textResponse = result.candidates[0].content.parts[0].text;
                return JSON.parse(textResponse);
            } catch (error) {
                console.error("Failed to parse JSON from API. Raw text:", result.candidates[0].content.parts[0].text, "Error:", error);
                return null;
            }
        }
        
        // === Gemini classroom classifier ===
        async function callGeminiClassifier(text) {
            const systemPrompt = `
        You are a Year 7 classroom safety checker. Analyze the student's text and return strict JSON.
        Definitions:
        - inappropriate = true if sexual content, hateful/harassing language, self-harm, explicit illegal activity, or doxxing/PII.
        - violence_severity: 0=none, 1=mild/cartoon peril (non-graphic), 2=moderate (injury, weapons, minimal blood detail), 3=graphic/gory (organs, viscera, detailed wounds).
        - gore_severity: 0=none, 1=implied blood, 2=blood/injury described, 3=graphic gore.
        - slang_flags: list any low-value meme/slang that reduces academic quality (e.g., "brain rot", "rizz", "sigma", "gyatt", "skibidi", "ohio core", "fanum tax", "npc", "touch grass", "based", "cringe", "pog", "sus", "edgelord"). Detect variants (brain-rot, brainrot).
        - includes_brainrot: true if "brain rot" or close variant appears.
        - rewrite_suggestion: one short, school-safe tip (<=20 words) that preserves intent but removes issues and tones down violence/gore.
        Do not echo slurs or sexual content in your JSON.
            `.trim();

            const schema = {
                type: "OBJECT",
                additionalProperties: false,
                properties: {
                    inappropriate:       { type: "BOOLEAN" },
                    reasons:             { type: "ARRAY", items: { type: "STRING" } },
                    violence_severity:   { type: "NUMBER" }, // 0-3
                    gore_severity:       { type: "NUMBER" }, // 0-3
                    slang_flags:         { type: "ARRAY", items: { type: "STRING" } },
                    includes_brainrot:   { type: "BOOLEAN" },
                    rewrite_suggestion: { type: "STRING" }
                }
            };

            const userPrompt = text;
            const result = await callGeminiForText(systemPrompt, userPrompt, schema);
            return result || {
                inappropriate: false,
                reasons: [],
                violence_severity: 0,
                gore_severity: 0,
                slang_flags: [],
                includes_brainrot: false,
                rewrite_suggestion: "Use precise verbs and non-graphic detail."
            };
        }

        // === Single gate used everywhere (writing + combat) ===
        async function screenTextForClassroom(text) {
            // 0) quick local denylist
            for (const re of DENYLIST) {
                if (re.test(text)) {
                    return {
                        allowed: false,
                        nudge: false,
                        message: "This includes content we can‚Äôt use at school. Please rewrite with school-appropriate language."
                    };
                }
            }

            // 1) Gemini classification
            const c = await callGeminiClassifier(text);
            if (!c) return { allowed: false, nudge: false, message: "Could not analyze text. Please try again." };

            const violence = Number(c.violence_severity || 0);
            const gore = Number(c.gore_severity || 0);
            const slangDetected = (c.includes_brainrot === true) || (Array.isArray(c.slang_flags) && c.slang_flags.length > 0);

            // 2) Decide: block vs nudge
            const mustBlock = Boolean(c.inappropriate) || violence > SAFETY.maxViolence || gore > SAFETY.maxGore;
            if (mustBlock) {
                return {
                    allowed: false,
                    nudge: false,
                    message: c.rewrite_suggestion || "Please rewrite without graphic detail, slang, or personal info."
                };
            }

            const nudge = (slangDetected && SAFETY.slangPolicy === "nudge") || violence === 1 || gore === 1;
            if (nudge) {
                const tip = c.rewrite_suggestion || "Replace slang with clear description; keep any danger non-graphic.";
                return { allowed: true, nudge: true, tip };
            }

            return { allowed: true, nudge: false };
        }


        async function callGeminiForQuestGeneration(writing) {
            const systemPrompt = `You are a Game Master for a narrative RPG. The player has described the next event in their story. Your job is to turn that description into a quest. Analyze the text and generate a JSON object.
            - quest_title: A title for this new quest.
            - quest_type: If the player described a monster/fight, return "writing_combat". Otherwise, return "writing".
            - npc_to_visit: The most logical existing NPC to start this quest (Village Elder, Fisherman, Sage of the Tides, War-Torn Elder).
            - objective: A short, clear objective for the player's quest log.
            - writing_prompt: A creative writing prompt for the climax of the story.
            - monster_name: If it's a combat quest, the name of the monster described.
            - monster_description: If it's a combat quest, a short description of the monster.`;
            
            const schema = {
                type: "OBJECT",
                properties: {
                    "quest_title": { "type": "STRING" },
                    "quest_type": { "type": "STRING" },
                    "npc_to_visit": { "type": "STRING" },
                    "objective": { "type": "STRING" },
                    "writing_prompt": { "type": "STRING" },
                    "monster_name": { "type": "STRING" },
                    "monster_description": { "type": "STRING" }
                }
            };
            
            return await callGeminiForText(systemPrompt, writing, schema);
        }

        async function callGeminiForAtmosphere(writing) {
            const systemPrompt = `Analyze the following text and extract its visual atmosphere. Provide your answer as a JSON object. The colors should be hex codes. The 'atmosphere' should be a single descriptive word. Example: { "skyColor": "#333333", "fogColor": "#454545", "groundColor": "#5a6a5a", "particleColor": "#cccccc", "atmosphere": "gloomy" }`;
            const schema = {
                type: "OBJECT",
                properties: {
                    "skyColor": { "type": "STRING" },
                    "fogColor": { "type": "STRING" },
                    "groundColor": { "type": "STRING" },
                    "particleColor": { "type": "STRING" },
                    "atmosphere": { "type": "STRING" }
                }
            };
            const userPrompt = `Based on this text, what is the visual atmosphere?\n\n${writing}`;
            return await callGeminiForText(systemPrompt, userPrompt, schema);
        }

        async function callGeminiForTTS(text, voiceName = "Kore") {
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        }
                    }
                }
            };
            const result = await callProxyAPI(TTS_API_URL, payload);
            if (!result) return null;
            
            const part = result.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                return URL.createObjectURL(wavBlob);
            }
            return null;
        }
        
        async function callGeminiForJournalExpansion(text) {
            const payload = {
                contents: [{ parts: [{ text: `Expand the following short story entry into a more detailed, cinematic paragraph suitable for a fantasy RPG game:\n\n${text}` }] }],
                generationConfig: {
                    responseMimeType: "text/plain"
                }
            };
            const result = await callProxyAPI(LLM_API_URL, payload);
            return result?.candidates?.[0]?.content?.parts?.[0]?.text;
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- CAMERA SETUP (TOP-DOWN) ---
        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 30;
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(0, 50, 0);
        camera.lookAt(0, 0, 0);
        scene.add(camera);

        // --- LIGHTING ---
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.8);
        scene.add(hemisphereLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-30, 50, -30);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- CHARACTER MODEL FACTORY ---
        function createCharacterModel(color) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.8, 1.6, 4, 8),
                new THREE.MeshStandardMaterial({ color: color })
            );
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 1.8;
            group.add(body);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16),
                new THREE.MeshStandardMaterial({ color: color })
            );
            head.position.y = 3.5;
            head.castShadow = true;
            group.add(head);

            return group;
        }

        // --- PLAYER & CONTROLS SETUP ---
        const player = createCharacterModel(0xffff00);
        player.position.set(0, 0, 20);
        scene.add(player);


        // --- WORLD GEOMETRY (GRASSLAND) ---
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4F7942 }); // Fern green
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);


        // --- Road ---
        function createGravelTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');

            // Base color
            context.fillStyle = '#966F33'; // Brownish base
            context.fillRect(0, 0, 256, 256);

            // Add pebbles of different shades
            for (let i = 0; i < 10000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const radius = Math.random() * 1.5;
                const gray = Math.floor(Math.random() * 100) + 80; // Random dark to mid gray/brown
                const color = `rgb(${gray}, ${gray - 10}, ${gray - 20})`;
                context.fillStyle = color;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(80, 5); // Repeat texture along the path
            return texture;
        }

        const roadPoints = [
            new THREE.Vector3(0, 0, 25), new THREE.Vector3(5, 0, 15),
            new THREE.Vector3(0, 0, 5), new THREE.Vector3(-5, 0, -5),
            new THREE.Vector3(-15, 0, -15), new THREE.Vector3(-20, 0, -5),
            new THREE.Vector3(-25, 0, 0), new THREE.Vector3(-20, 0, 10),
            new THREE.Vector3(10, 0, -25)
        ];
        const roadCurve = new THREE.CatmullRomCurve3(roadPoints);
        // Create a tube and then flatten it to look like a road
        const roadGeometry = new THREE.TubeGeometry(roadCurve, 128, 2.5, 8, false);
        const roadMaterial = new THREE.MeshStandardMaterial({ map: createGravelTexture() });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.scale.y = 0.05; // Make it very flat
        road.position.y = 0.1; // Lift it slightly above the ground to prevent flickering
        road.receiveShadow = true;
        scene.add(road);


        // --- Instanced Trees & Rocks ---
        const treeCount = 100;
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 8, 8);
        const leavesGeometry = new THREE.IcosahedronGeometry(4, 0); // More stylized leaves
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22, flatShading: true });
        const instancedTrunks = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, treeCount);
        const instancedLeaves = new THREE.InstancedMesh(leavesGeometry, leavesMaterial, treeCount);
        instancedTrunks.castShadow = true;
        instancedLeaves.castShadow = true;
        const dummy = new THREE.Object3D();
        for (let i = 0; i < treeCount; i++) {
            const x = (Math.random() - 0.5) * 400;
            const z = (Math.random() - 0.5) * 400;
            dummy.position.set(x, 4, z);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            const scale = Math.random() * 0.5 + 0.75;
            dummy.scale.set(scale, scale, scale);
            dummy.updateMatrix();
            instancedTrunks.setMatrixAt(i, dummy.matrix);
            
            dummy.position.y = 10;
            dummy.updateMatrix();
            instancedLeaves.setMatrixAt(i, dummy.matrix);
        }
        scene.add(instancedTrunks);
        scene.add(instancedLeaves);
        
        // Add Rocks
        const rockCount = 50;
        const rockGeometry = new THREE.IcosahedronGeometry(1, 0);
        const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, flatShading: true });
        const instancedRocks = new THREE.InstancedMesh(rockGeometry, rockMaterial, rockCount);
        for (let i = 0; i < rockCount; i++) {
            dummy.position.set((Math.random() - 0.5) * 400, Math.random() * 2, (Math.random() - 0.5) * 400);
            dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            const scale = Math.random() * 2 + 1;
            dummy.scale.set(scale, scale, scale);
            dummy.updateMatrix();
            instancedRocks.setMatrixAt(i, dummy.matrix);
        }
        scene.add(instancedRocks);
        
        // --- Ambient Particles ---
        const particleCount = 500;
        const particlesGeometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 200;
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particleMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0xeeeeff });
        const particleMesh = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleMesh);


        // --- GAME OBJECTS & LOGIC ---
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let interactKeyPressed = false;
        const moveSpeed = 8.0;
        const clock = new THREE.Clock();
        let canMove = true; // Start with movement enabled for the animation loop
        let gameStarted = false; // Flag to check if the game is active
        const gameState = {
            currentQuestIndex: 0,
            quests: [
                { id: "AWAKENING", type: "writing", title: "A Stranger's Arrival", objective: "Introduce yourself to the Village Elder.", writingPrompt: "The Village Elder looks you up and down, a hint of suspicion in their eyes. 'We don't get many visitors here,' they say. 'Who are you, and what brings you to our lands?' Describe your character's appearance, personality, and traits. Introduce yourself to the Elder.", isComplete: false, npc: "Village Elder", rewardXP: 100 },
                { id: "RISING_ACTION", type: "writing", title: "The Spreading Sickness", objective: "The Elder, now trusting you, asks you to find the Fisherman to learn more about the growing blight.", writingPrompt: "The Fisherman points a trembling hand towards the horizon. 'It started as a small slick,' he rasps, 'but now... it breathes.' He begs you to describe the encroaching horror so the village can understand what they face. Write a vivid description of the monstrous, growing slick of pollution.", isComplete: false, npc: "Fisherman", rewardXP: 150 }
            ],
            canInteractWith: null,
            isCombatActive: false
        };

        const villageElder = createCharacterModel(0x0000ff);
        villageElder.position.set(0, 0, 0);
        villageElder.name = "Village Elder";
        scene.add(villageElder);

        const fisherman = createCharacterModel(0x808080);
        fisherman.position.set(-15, 0, -15);
        fisherman.name = "Fisherman";
        scene.add(fisherman);
        
        const sageOfTheTides = createCharacterModel(0x008080);
        sageOfTheTides.position.set(10, 0, -25);
        sageOfTheTides.name = "Sage of the Tides";
        scene.add(sageOfTheTides);

        const warTornElder = createCharacterModel(0x5a2e2e);
        warTornElder.position.set(-20, 0, 10);
        warTornElder.name = "War-Torn Elder";
        scene.add(warTornElder);

        const pollutionElemental = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true }));
        pollutionElemental.position.set(-25, 2, 0);
        pollutionElemental.name = "Pollution Elemental";
        pollutionElemental.castShadow = true;
        pollutionElemental.visible = false;
        scene.add(pollutionElemental);
        let createdMonster = {
            object: pollutionElemental,
            name: "Pollution Elemental",
            description: "a fearsome elemental born of plastic and sludge",
            baseHealth: 100
        };

        // --- COMBAT STATE ---
        let combatState = {
            playerHP: 100,
            enemyHP: 100,
            playerDamage: 10,
            enemyDamage: 5,
            isPlayerTurn: true,
            useSpecialMove: false
        };

        // --- UI Elements ---
        const uiContainer = document.getElementById('ui-container');
        const characterCreator = document.getElementById('character-creator');
        const startGameBtn = document.getElementById('start-game-btn');
        const guardianTypeOptions = document.getElementById('guardian-type-options');
        const customGuardianInput = document.getElementById('custom-guardian-input');
        const guardianDomainOptions = document.getElementById('guardian-domain-options');
        
        const startModal = document.getElementById('start-modal');
        const continueGameBtn = document.getElementById('continue-game-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        const questLog = document.getElementById('quest-log');
        const questTitle = document.getElementById('quest-title');
        const questObjective = document.getElementById('quest-objective');
        const playerLevelInfo = document.getElementById('player-level-info');
        const xpBar = document.getElementById('xp-bar');
        const playerAttack = document.getElementById('player-attack');
        const playerHealth = document.getElementById('player-health');
        
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueTitle = document.getElementById('dialogue-title');
        const dialogueText = document.getElementById('dialogue-text');
        const dialogueButton = document.getElementById('dialogue-button');

        const writingChallenge = document.getElementById('writing-challenge');
        const narrativeStage = document.getElementById('narrative-stage');
        const challengeTitle = document.getElementById('challenge-title');
        const challengePrompt = document.getElementById('challenge-prompt');
        const writingInput = document.getElementById('writing-input');
        const writingSubmit = document.getElementById('writing-submit');

        const dynamicQuestCreator = document.getElementById('dynamic-quest-creator');
        const dynamicQuestInput = document.getElementById('dynamic-quest-input');
        const dynamicQuestSubmit = document.getElementById('dynamic-quest-submit');

        const questComplete = document.getElementById('quest-complete');
        const rewardText = document.getElementById('reward-text');
        const continueQuestingBtn = document.getElementById('continue-questing-btn');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const getTipBtn = document.getElementById('get-tip-btn');
        const improvementSuggestion = document.getElementById('improvement-suggestion');
        
        const monsterCreatedPanel = document.getElementById('monster-created-panel');
        const monsterName = document.getElementById('monster-name');
        const monsterDescription = document.getElementById('monster-description');
        const startCombatBtn = document.getElementById('start-combat-btn');

        const combatPanel = document.getElementById('combat-panel');
        const combatTitle = document.getElementById('combat-title');
        const playerHealthBar = document.getElementById('player-health-bar');
        const enemyHealthBar = document.getElementById('enemy-health-bar');
        const combatLog = document.getElementById('combat-log');
        const combatPrompt = document.getElementById('combat-prompt');
        const combatWritingInput = document.getElementById('combat-writing-input');
        const combatSubmitBtn = document.getElementById('combat-submit-btn');
        const specialMoveBtn = document.getElementById('special-move-btn');
        
        const journalPanel = document.getElementById('journal-panel');
        const journalEntries = document.getElementById('journal-entries');
        const achievementsList = document.getElementById('achievements-list');
        const storyTab = document.getElementById('story-tab');
        const achievementsTab = document.getElementById('achievements-tab');
        const openJournalBtn = document.getElementById('open-journal-btn');
        const closeJournalBtn = document.getElementById('close-journal-btn');
        const copyJournalBtn = document.getElementById('copy-journal-btn');

        const interactPrompt = document.getElementById('interact-prompt');
        const loadingMessage = document.getElementById('loading-message');
        const feedbackArea = document.getElementById('feedback-area');
        
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');
        
        const writingTipsBox = document.getElementById('writing-tips-box');
        const currentTips = document.getElementById('current-tips');

        // --- UI LOGIC ---
        function showPanel(panel, focusElement = null) {
            panel.style.display = panel.classList.contains('modal-backdrop') ? 'flex' : 'block';
            if (focusElement) {
                focusElement.focus();
            }
        }
        
        function hidePanel(panel) {
            panel.style.display = 'none';
        }

        function updateQuestLog() {
            const currentQuest = gameState.quests[gameState.currentQuestIndex];
            if (currentQuest) {
                questTitle.textContent = currentQuest.title;
                questObjective.textContent = currentQuest.objective;
            } else {
                questTitle.textContent = "All quests complete!";
                questObjective.textContent = "You have brought peace to the lands.";
            }
            playerLevelInfo.textContent = `Level ${playerStats.level} Guardian`;
            xpBar.style.width = `${(playerStats.xp / playerStats.xpToNextLevel) * 100}%`;
            playerAttack.textContent = playerStats.baseDamage;
            playerHealth.textContent = playerStats.baseHealth;
        }

        function unlockAchievement(id) {
            if (!achievements[id] || playerStats.achievements[id]) return;

            playerStats.achievements[id] = true;
            achievements[id].unlocked = true;
            const notification = document.getElementById('achievement-notification');
            notification.textContent = `Achievement Unlocked: ${achievements[id].title}`;
            notification.style.bottom = '20px';
            notification.style.opacity = 1;

            setTimeout(() => {
                notification.style.bottom = '-100px';
                notification.style.opacity = 0;
            }, 3000);
        }

        // --- MAIN GAME FLOW ---
        function handleInteraction() {
            if (gameState.isCombatActive || !gameState.canInteractWith) return;

            // Hide the prompt immediately upon successful interaction
            interactPrompt.style.display = 'none';
            
            // Check for memory fragment interaction
            if (gameState.canInteractWith.type === 'fragment') {
                const fragment = memoryFragments[gameState.canInteractWith.index];
                if (!fragment.collected) {
                    fragment.collected = true;
                    playerStats.collectedFragments++;
                    const mesh = memoryFragmentMeshes[gameState.canInteractWith.index];
                    if(mesh) mesh.visible = false;
                    showMessage(fragment.text);
                    if (playerStats.collectedFragments === memoryFragments.length) {
                        unlockAchievement("LOREMASTER");
                    }
                }
                return;
            }


            const npcName = gameState.canInteractWith;
            const currentQuest = gameState.quests[gameState.currentQuestIndex];
            
            if (currentQuest && currentQuest.npc === npcName && !currentQuest.isComplete) {
                canMove = false;
                dialogueTitle.textContent = npcName;

                if (currentQuest.type === "writing") {
                     showWritingChallenge();
                } else if (currentQuest.type === "writing_combat") {
                     dialogueText.textContent = `The ${createdMonster.name} is a blight upon this land. Are you ready to face it with your words?`;
                     dialogueButton.textContent = "I'm Ready";
                     dialogueButton.onclick = () => {
                         hidePanel(dialogueBox);
                         createdMonster.object.visible = true;
                         startWritingCombat();
                     };
                     showPanel(dialogueBox);
                }
            }
        }
        
        function showWritingChallenge() {
            const stage = narrativeStages[Math.min(gameState.currentQuestIndex, narrativeStages.length - 1)];
            narrativeStage.textContent = stage;
            const currentQuest = gameState.quests[gameState.currentQuestIndex];
            
            challengeTitle.textContent = `Challenge: ${currentQuest.title}`;
            // Use the new, more descriptive writingPrompt from the quest object
            challengePrompt.textContent = currentQuest.writingPrompt;
            writingInput.value = "";
            feedbackArea.innerHTML = "";
            feedbackArea.className = 'feedback-area';
            
            currentTips.textContent = writingTips[stage];
            writingTipsBox.style.display = 'block';

            // Reset the submit button to its initial state each time the panel is shown
            writingSubmit.disabled = false;
            writingSubmit.textContent = "Weave Your Tale";
            
            hidePanel(dialogueBox);
            showPanel(writingChallenge, writingInput);
        }

        async function submitWriting() {
            const submission = writingInput.value.trim();
            if (submission.length < 20) {
                showMessage("Your entry is too short. Please write a more detailed description.");
                return;
            }

            // SAFEGUARD FIRST
            const gate = await screenTextForClassroom(submission);
            if (!gate.allowed) {
                feedbackArea.textContent = gate.message;
                feedbackArea.className = 'feedback-area feedback-error';
                writingSubmit.disabled = false;
                writingSubmit.textContent = "Try Again";
                return;
            }
            if (gate.nudge) {
                feedbackArea.textContent = `Tip: ${gate.tip}`;
                feedbackArea.className = 'feedback-area feedback-success';
            } else {
                 feedbackArea.textContent = '';
                 feedbackArea.className = 'feedback-area';
            }

            // Now continue with your existing evaluation flow
            writingSubmit.disabled = true;
            writingSubmit.textContent = "Analyzing...";
            lastSubmission = submission;

            const systemPrompt = `You are an English teacher evaluating a Year 7 student's story entry. Evaluate it on Clarity, Creativity, and Grammar. Provide a one-sentence feedback for each, and a final "Overall Suggestion". The feedback should be constructive and encouraging.
            The student is writing the "${narrativeStages[gameState.currentQuestIndex]}" part of their story.
            The prompt was: "${gameState.quests[gameState.currentQuestIndex].writingPrompt}"`;
            
            const schema = {
                type: "OBJECT", properties: {
                    "validation": { "type": "STRING", description: "Return 'pass' or 'fail'." },
                    "clarity_feedback": { "type": "STRING" },
                    "creativity_feedback": { "type": "STRING" },
                    "grammar_feedback": { "type": "STRING" },
                    "overall_suggestion": { "type": "STRING" },
                    "reward_multiplier": { "type": "NUMBER", description: "A number from 0.5 to 1.5 based on quality." }
                }
            };

            const validationResponse = await callGeminiForText(systemPrompt, submission, schema);
            lastValidationResponse = validationResponse;

            if (!validationResponse) {
                showMessage("There was an error analyzing your writing. The service may be unavailable. Please try again.");
                writingSubmit.disabled = false;
                writingSubmit.textContent = "Weave Your Tale";
                return;
            }

            if (validationResponse.validation === 'pass') {
                completeQuest();
            } else {
                feedbackArea.textContent = validationResponse.overall_suggestion || "This doesn't seem to fit the prompt. Please try rewriting it.";
                feedbackArea.className = 'feedback-area feedback-error';
                writingSubmit.disabled = false;
                writingSubmit.textContent = "Try Again";
            }
        }

        function completeQuest() {
            const currentQuest = gameState.quests[gameState.currentQuestIndex];
            currentQuest.isComplete = true;

            const baseXP = currentQuest.rewardXP;
            const finalXP = Math.round(baseXP * (lastValidationResponse.reward_multiplier || 1));
            playerStats.xp += finalXP;

            playerStats.journal.push({
                stage: narrativeStages[gameState.currentQuestIndex],
                title: currentQuest.title,
                text: lastSubmission
            });

            hidePanel(writingChallenge);
            writingTipsBox.style.display = 'none';
            
            unlockAchievement("STORY_BEGINS");
            saveGame(true); // Autosave after quest completion

            if (gameState.currentQuestIndex === 1) { // After Rising Action
                showDynamicQuestCreator();
                changeWorldAtmosphere(lastSubmission);
            } else {
                showQuestComplete(finalXP);
            }
            
            if (gameState.currentQuestIndex >= gameState.quests.length - 1) { // Check if it's the last quest
                unlockAchievement("SAVIOR");
            }

            levelUpCheck();
            updateQuestLog();
        }

        function showDynamicQuestCreator() {
            showPanel(dynamicQuestCreator, dynamicQuestInput);
        }

        async function submitDynamicQuest() {
            const submission = dynamicQuestInput.value.trim();
            if (submission.length < 20) {
                showMessage("Please write a more detailed description of what happens next.");
                return;
            }
            
            dynamicQuestSubmit.disabled = true;
            dynamicQuestSubmit.textContent = "Forging Fate...";

            // SAFEGUARD FIRST
            const gate = await screenTextForClassroom(submission);
            if (!gate.allowed) {
                showMessage(gate.message);
                dynamicQuestSubmit.disabled = false;
                dynamicQuestSubmit.textContent = "Shape the Climax";
                return;
            }

            const questData = await callGeminiForQuestGeneration(submission);

            if (questData) {
                const newQuest = {
                    id: "DYNAMIC_CLIMAX",
                    type: questData.quest_type,
                    title: questData.quest_title,
                    objective: questData.objective,
                    writingPrompt: questData.writing_prompt,
                    isComplete: false,
                    npc: questData.npc_to_visit,
                    rewardXP: 250
                };

                // Insert the new quest as the Climax
                gameState.quests.splice(2, 0, newQuest);

                // If it's a combat quest, create the monster
                if (newQuest.type === 'writing_combat' && questData.monster_name) {
                    currentMonsterName = questData.monster_name;
                    currentMonsterDescription = questData.monster_description;
                    createdMonster.name = currentMonsterName;
                    createdMonster.description = currentMonsterDescription;
                    createdMonster.object.visible = true;
                }

                // Add standard Falling Action and Resolution
                if (gameState.quests.length === 3) {
                     gameState.quests.push({ id: "FALLING_ACTION", type: "writing", title: "The Aftermath", objective: "Speak to the Sage to reflect on your actions.", writingPrompt: "The Sage of the Tides asks you to reflect on the climax of your story. Describe the immediate consequences of your actions. What has changed in the world?", isComplete: false, npc: "Sage of the Tides", rewardXP: 200 });
                     gameState.quests.push({ id: "RESOLUTION", type: "writing", title: "A New Dawn", objective: "Return to the Village Elder to share the final chapter.", writingPrompt: "Your actions have changed the world. Describe the scene that lies before you now. Is the water clear? Are the people hopeful? Write the final chapter of this story.", isComplete: false, npc: "Village Elder", rewardXP: 300 });
                }

                playerStats.journal.push({
                    stage: "Rising Action (cont.)",
                    title: "The Storyteller's Choice",
                    text: submission
                });
                
                hidePanel(dynamicQuestCreator);
                continueToNextQuest();

            } else {
                showMessage("There was an error shaping your story. Please try again.");
                dynamicQuestSubmit.disabled = false;
                dynamicQuestSubmit.textContent = "Shape the Climax";
            }
        }

        async function changeWorldAtmosphere(text) {
            const atmoData = await callGeminiForAtmosphere(text);
            if (atmoData && atmoData.skyColor) {
                console.log("New atmosphere data:", atmoData);
                startAtmo.sky = scene.background.clone();
                startAtmo.fog = scene.fog.color.clone();
                startAtmo.ground = ground.material.color.clone();
                startAtmo.particles = particleMesh.material.color.clone();

                targetAtmo.sky = new THREE.Color(atmoData.skyColor);
                targetAtmo.fog = new THREE.Color(atmoData.fogColor);
                targetAtmo.ground = new THREE.Color(atmoData.groundColor);
                targetAtmo.particles = new THREE.Color(atmoData.particleColor);
                
                atmosphereTransitionStart = clock.getElapsedTime();
                isTransitioningAtmosphere = true;
            }
        }
        
        function showQuestComplete(xpGained) {
            rewardText.textContent = `You earned ${xpGained} XP!`;
            improvementSuggestion.innerHTML = ''; // Clear previous feedback
            if (lastValidationResponse) {
                improvementSuggestion.innerHTML = `
                    <h3 class="font-bold text-teal-800">Feedback:</h3>
                    <p><strong>Clarity:</strong> ${lastValidationResponse.clarity_feedback || 'Well done.'}</p>
                    <p><strong>Creativity:</strong> ${lastValidationResponse.creativity_feedback || 'Nice ideas.'}</p>
                    <p><strong>Grammar:</strong> ${lastValidationResponse.grammar_feedback || 'Looks good.'}</p>
                    <p class="mt-2"><strong>Suggestion:</strong> ${lastValidationResponse.overall_suggestion || 'Keep it up!'}</p>
                `;
            }
            showPanel(questComplete);
        }

        function levelUpCheck() {
            while (playerStats.xp >= playerStats.xpToNextLevel) {
                playerStats.level++;
                playerStats.xp -= playerStats.xpToNextLevel;
                playerStats.xpToNextLevel = Math.round(playerStats.xpToNextLevel * 1.5);
                playerStats.baseHealth += 20;
                playerStats.baseDamage += 5;
                showMessage(`Congratulations! You've reached Level ${playerStats.level}!`);
            }
            // Update special move button availability
            specialMoveBtn.disabled = playerStats.level < 2;
        }
        
        function continueToNextQuest() {
             hidePanel(questComplete);
             hidePanel(monsterCreatedPanel);
             gameState.currentQuestIndex++;
             if (gameState.currentQuestIndex >= gameState.quests.length) {
                 showMessage("You have completed all the quests! The world is safe, for now.");
                 canMove = true;
             } else {
                updateQuestLog();
                canMove = true;
             }
        }
        
        function tryAgain() {
            hidePanel(questComplete);
            writingInput.value = lastSubmission;
            feedbackArea.innerHTML = "";
            showPanel(writingChallenge);
        }

        // --- NARRATIVE COMBAT LOGIC ---

        function startWritingCombat() {
            gameState.isCombatActive = true;
            canMove = false;
            
            combatState.playerHP = playerStats.baseHealth;
            combatState.enemyHP = createdMonster.baseHealth;
            combatState.isPlayerTurn = true;
            
            combatTitle.textContent = `Battle with ${createdMonster.name}!`;
            combatLog.innerHTML = `A wild ${createdMonster.name} appears! ${createdMonster.description}.<br>`;
            
            updateCombatUI();
            nextCombatTurn();
            showPanel(combatPanel, combatWritingInput);
        }

        function nextCombatTurn() {
            if (!gameState.isCombatActive) return;

            if (combatState.isPlayerTurn) {
                combatSubmitBtn.disabled = false;
                combatWritingInput.disabled = false;
                
                if (combatState.useSpecialMove) {
                     combatPrompt.textContent = "Use a simile to describe your attack!";
                     combatWritingInput.placeholder = "e.g., My hero strikes like lightning...";
                } else {
                     combatPrompt.textContent = "The creature waits. Describe your attack!";
                     combatWritingInput.placeholder = "e.g., I unleash a torrent of water...";
                }
                combatWritingInput.focus();
            } else {
                combatSubmitBtn.disabled = true;
                combatWritingInput.disabled = true;
                combatPrompt.textContent = "Enemy is attacking...";
                setTimeout(enemyTurn, 1500);
            }
        }

        async function submitCombatWriting() {
            const action = combatWritingInput.value.trim();
            if (action.length < 10) {
                addToCombatLog("Your description is too short. Be more descriptive to land a solid hit!", "red");
                return;
            }
            
            // SAFEGUARD FIRST
            const gate = await screenTextForClassroom(action);
            if (!gate.allowed) {
                addToCombatLog("That move isn‚Äôt school-safe. " + (gate.message || "Try a non-graphic description."), "red");
                return;
            }
            if (gate.nudge) {
                addToCombatLog("Tip: " + gate.tip, "green");
            }

            // ...then proceed with your existing scoring logic
            combatSubmitBtn.disabled = true;
            combatSubmitBtn.textContent = "Analyzing...";

            let systemPrompt;
            if(combatState.useSpecialMove) {
                systemPrompt = `The player is using a simile in combat. Analyze their sentence. If it's a valid simile, assign damage between 40-60. If not, assign 10 damage. Provide brief, encouraging feedback.`;
            } else {
                systemPrompt = `The player is describing an attack. Analyze their sentence for strong verbs, imagery, and creativity. Assign damage between 15-35 based on quality (a simple sentence should be closer to 15, a highly descriptive one closer to 35). Provide brief, encouraging feedback.`;
            }
            
            const schema = { type: "OBJECT", properties: { "damage": { "type": "NUMBER" }, "feedback": { "type": "STRING" } } };
            const response = await callGeminiForText(systemPrompt, action, schema);

            if (response) {
                // Combine AI-evaluated damage with the player's base stats for more impact
                const finalDamage = (response.damage || 15) + playerStats.baseDamage;
                combatState.enemyHP -= finalDamage;
                addToCombatLog(`Your words manifest into a powerful blow! (${response.feedback}) You deal ${finalDamage} damage.`, "green");
                playerStats.journal.push({
                    stage: "Combat", title: `Turn vs ${createdMonster.name}`, text: action
                });
                 if (combatState.useSpecialMove) unlockAchievement("WORD_WEAVER");
            } else {
                const randomDamage = Math.floor(Math.random() * 10) + playerStats.baseDamage; // Still include base damage
                combatState.enemyHP -= randomDamage;
                addToCombatLog(`Your attack connects! You deal ${randomDamage} damage.`, "green");
            }
            
            combatWritingInput.value = "";
            combatSubmitBtn.textContent = "Attack!";
            combatState.useSpecialMove = false; // Reset special move state
            updateCombatUI();

            if (combatState.enemyHP <= 0) {
                endCombat(true);
            } else {
                combatState.isPlayerTurn = false;
                nextCombatTurn();
            }
        }

        function enemyTurn() {
            const damage = Math.floor(Math.random() * 10) + (playerStats.level * 2);
            combatState.playerHP -= damage;
            addToCombatLog(`${createdMonster.name} retaliates, dealing ${damage} damage to you!`, "red");
            updateCombatUI();

            if (combatState.playerHP <= 0) {
                endCombat(false);
            } else {
                combatState.isPlayerTurn = true;
                nextCombatTurn();
            }
        }

        function addToCombatLog(message, color = "black") {
            combatLog.innerHTML += `<span style="color:${color};">${message}</span><br>`;
            combatLog.scrollTop = combatLog.scrollHeight;
        }

        function updateCombatUI() {
            playerHealthBar.style.width = `${Math.max(0, (combatState.playerHP / playerStats.baseHealth) * 100)}%`;
            enemyHealthBar.style.width = `${Math.max(0, (combatState.enemyHP / createdMonster.baseHealth) * 100)}%`;
        }

        function endCombat(playerWon) {
            gameState.isCombatActive = false;
            hidePanel(combatPanel);
            
            if (playerWon) {
                unlockAchievement("FIRST_VICTORY");
                addToCombatLog("You are victorious!");
                const currentQuest = gameState.quests[gameState.currentQuestIndex];
                currentQuest.isComplete = true;
                playerStats.xp += currentQuest.rewardXP;
                
                hidePanel(combatPanel);
                showQuestComplete(currentQuest.rewardXP);
                createdMonster.object.visible = false;
                saveGame(true); // Autosave after combat win
            } else {
                showMessage("You have been defeated. Rest and try again.");
                player.position.set(0, 0, 20);
                canMove = true;
            }
             updateQuestLog();
        }

        // --- EVENT LISTENERS ---
        startGameBtn.addEventListener('click', () => {
             const selectedType = guardianTypeOptions.querySelector('.selected');
             const selectedDomain = guardianDomainOptions.querySelector('.selected');

             if (!selectedType || !selectedDomain) {
                 showMessage("Please select a Guardian Type and a Realm.");
                 return;
             }

             characterData.type = selectedType.dataset.type;
             characterData.domain = selectedDomain.dataset.domain;
             
             if (characterData.type === 'custom') {
                 const customName = customGuardianInput.value.trim();
                 if (customName.length < 3) {
                     showMessage("Please enter a name for your custom guardian.");
                     return;
                 }
                 characterData.type = customName;
             }

             hidePanel(characterCreator);
             uiContainer.style.visibility = 'visible';
             canMove = true;
             gameStarted = true;
             updateQuestLog();
             saveGame(true); // Initial autosave
        });
        
        continueGameBtn.addEventListener('click', () => {
            hidePanel(startModal);
            loadGame();
        });

        newGameBtn.addEventListener('click', () => {
            hidePanel(startModal);
            showPanel(characterCreator);
        });
        
        guardianTypeOptions.addEventListener('click', e => {
            const option = e.target.closest('.creator-option');
            if (option) {
                guardianTypeOptions.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                option.classList.add('selected');
                customGuardianInput.style.display = option.dataset.type === 'custom' ? 'block' : 'none';
            }
        });
        
        guardianDomainOptions.addEventListener('click', e => {
             const option = e.target.closest('.creator-option');
             if (option) {
                 guardianDomainOptions.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                 option.classList.add('selected');
             }
        });
        
        writingSubmit.addEventListener('click', submitWriting);
        dynamicQuestSubmit.addEventListener('click', submitDynamicQuest);
        continueQuestingBtn.addEventListener('click', continueToNextQuest);
        tryAgainBtn.addEventListener('click', tryAgain);
        
        startCombatBtn.addEventListener('click', () => {
            hidePanel(monsterCreatedPanel);
            hidePanel(questComplete); // Also hide quest complete panel if it was open
            continueToNextQuest(); // This now just moves to the next quest index
        });
        combatSubmitBtn.addEventListener('click', submitCombatWriting);
        specialMoveBtn.addEventListener('click', () => {
            combatState.useSpecialMove = true;
            nextCombatTurn();
        });


        openJournalBtn.addEventListener('click', () => {
            // Setup journal entries
            journalEntries.innerHTML = "";
            playerStats.journal.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'journal-entry';
                entryDiv.innerHTML = `
                    <h3>${entry.title}</h3>
                    <p class="journal-stage">${entry.stage}</p>
                    <p>${entry.text}</p>
                    <button class="expand-btn">Expand</button>
                `;
                journalEntries.appendChild(entryDiv);
            });

            // Setup achievements list
            achievementsList.innerHTML = "";
            for (const id in achievements) {
                const ach = achievements[id];
                const isUnlocked = playerStats.achievements[id];
                const achDiv = document.createElement('div');
                achDiv.className = isUnlocked ? 'achievement unlocked' : 'achievement locked';
                achDiv.innerHTML = `
                    <h3>${ach.title}</h3>
                    <p>${isUnlocked ? ach.description : '??????????'}</p>
                `;
                achievementsList.appendChild(achDiv);
            }

            showPanel(journalPanel);
            canMove = false;
        });
        
        storyTab.addEventListener('click', () => {
            storyTab.classList.add('active');
            achievementsTab.classList.remove('active');
            journalEntries.style.display = 'block';
            achievementsList.style.display = 'none';
        });

        achievementsTab.addEventListener('click', () => {
            achievementsTab.classList.add('active');
            storyTab.classList.remove('active');
            achievementsList.style.display = 'block';
            journalEntries.style.display = 'none';
        });

        closeJournalBtn.addEventListener('click', () => {
            hidePanel(journalPanel);
            canMove = true;
        });
        
        copyJournalBtn.addEventListener('click', () => {
            const storyText = playerStats.journal.map(e => `## ${e.title} (${e.stage})\n\n${e.text}`).join('\n\n---\n\n');
            navigator.clipboard.writeText(storyText)
                .then(() => showMessage("Your story has been copied to the clipboard!"))
                .catch(err => showMessage("Failed to copy story."));
        });
        
        journalEntries.addEventListener('click', async (e) => {
            if (e.target.classList.contains('expand-btn')) {
                const entryDiv = e.target.closest('.journal-entry');
                const originalText = entryDiv.querySelector('p:not(.journal-stage)').textContent;
                e.target.textContent = "Expanding...";
                e.target.disabled = true;

                const expandedText = await callGeminiForJournalExpansion(originalText);
                
                if (expandedText) {
                    entryDiv.querySelector('p:not(.journal-stage)').textContent = expandedText;
                }
                
                e.target.remove();
            }
        });
        
        messageButton.addEventListener('click', () => {
             hidePanel(messageBox);
             canMove = true;
        });

        document.getElementById('minimize-quest-log').addEventListener('click', () => {
            questLog.classList.toggle('minimized');
            document.getElementById('minimize-quest-log').textContent = questLog.classList.contains('minimized') ? '+' : '-';
        });

        window.addEventListener('keydown', (event) => {
            // Prevent game controls from firing when typing in an input field
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                // Allow 'Enter' key to submit combat actions for a better user experience
                if (event.key === 'Enter' && activeElement.id === 'combat-writing-input') {
                    event.preventDefault(); // Prevent default 'Enter' behavior (like line breaks)
                    submitCombatWriting();
                }
                return; // Exit early and allow normal typing for all other keys
            }

            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyE': if (!interactKeyPressed) { handleInteraction(); interactKeyPressed = true; } break;
            }
        });

        window.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyE': interactKeyPressed = false; break;
            }
        });

        function showMessage(text) {
            messageText.textContent = text;
            showPanel(messageBox, messageButton);
            canMove = false;
        }

        function createMemoryFragments() {
            const fragmentGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const fragmentMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });

            memoryFragments.forEach(fragmentData => {
                const mesh = new THREE.Mesh(fragmentGeometry, fragmentMaterial.clone());
                mesh.position.copy(fragmentData.pos);
                scene.add(mesh);
                memoryFragmentMeshes.push(mesh);
            });
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            if (isTransitioningAtmosphere) {
                const progress = (elapsedTime - atmosphereTransitionStart) / (atmosphereTransitionDuration / 1000);
                if (progress < 1) {
                    scene.background.lerpColors(startAtmo.sky, targetAtmo.sky, progress);
                    scene.fog.color.lerpColors(startAtmo.fog, targetAtmo.fog, progress);
                    ground.material.color.lerpColors(startAtmo.ground, targetAtmo.ground, progress);
                    particleMesh.material.color.lerpColors(startAtmo.particles, targetAtmo.particles, progress);
                } else {
                    isTransitioningAtmosphere = false;
                    scene.background.copy(targetAtmo.sky);
                    scene.fog.color.copy(targetAtmo.fog);
                    ground.material.color.copy(targetAtmo.ground);
                    particleMesh.material.color.copy(targetAtmo.particles);
                }
            }

             // Animate Particles
            particleMesh.rotation.y += delta * 0.05;
            
            // Animate memory fragments
            memoryFragmentMeshes.forEach(mesh => {
                mesh.rotation.y += delta;
                mesh.position.y = mesh.userData.baseY + Math.sin(elapsedTime * 2 + mesh.position.x) * 0.25;
            });
            
            if (!gameStarted) return; // Don't run game logic if the game hasn't started

            if (canMove) {
                const moveDirection = new THREE.Vector3(0, 0, 0);
                if (moveForward) moveDirection.z -= 1;
                if (moveBackward) moveDirection.z += 1;
                if (moveLeft) moveDirection.x -= 1;
                if (moveRight) moveDirection.x += 1;
                
                if (moveDirection.lengthSq() > 0) {
                    moveDirection.normalize().multiplyScalar(moveSpeed * delta);
                    player.position.add(moveDirection);
                }
            }

            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 50;
            camera.lookAt(player.position);
            
            // Check for interactable objects
            let closeInteractable = null;
            const npcs = [villageElder, fisherman, sageOfTheTides, warTornElder];
            npcs.forEach(npc => {
                const distance = player.position.distanceTo(npc.position);
                if (distance < 5) {
                    closeInteractable = npc.name;
                }
            });
            
            memoryFragmentMeshes.forEach((mesh, index) => {
                if (mesh.visible) {
                    const distance = player.position.distanceTo(mesh.position);
                    if (distance < 2.5) {
                        closeInteractable = { type: 'fragment', index: index };
                    }
                }
            });
            
            // Only show the prompt if the player can move and is not in combat
            if (closeInteractable && !gameState.isCombatActive && canMove) {
                gameState.canInteractWith = closeInteractable;
                interactPrompt.style.display = 'block';
            } else {
                // Hide the prompt if the player cannot interact
                gameState.canInteractWith = null;
                interactPrompt.style.display = 'none';
            }
            
            // Update NPC name tags
            updateNpcNameTags();

            renderer.render(scene, camera);
        }
        
        function updateNpcNameTags() {
            const npcs = [
                { obj: villageElder, el: document.getElementById('elder-name') },
                { obj: fisherman, el: document.getElementById('fisherman-name') },
                { obj: sageOfTheTides, el: document.getElementById('sage-name') },
                { obj: warTornElder, el: document.getElementById('war-torn-elder-name') },
            ];

            // If player movement is disabled, it means a UI panel is open. Hide all tags.
            if (!canMove) {
                npcs.forEach(npc => {
                    npc.el.style.display = 'none';
                });
                return; // Exit early
            }

            npcs.forEach(npc => {
                const screenPos = toScreenPosition(npc.obj, camera);
                if (screenPos) {
                    npc.el.style.display = 'block';
                    npc.el.style.left = `${screenPos.x}px`;
                    npc.el.style.top = `${screenPos.y - 45}px`; // Adjust offset for new model
                } else {
                    npc.el.style.display = 'none';
                }
            });
        }

        function toScreenPosition(obj, camera) {
            const vector = new THREE.Vector3();
            // Use the object's world position for the calculation
            obj.getWorldPosition(vector);
            vector.project(camera);

            vector.x = (vector.x + 1) * window.innerWidth / 2;
            vector.y = -(vector.y - 1) * window.innerHeight / 2;

            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            const objectDirection = new THREE.Vector3().subVectors(obj.position, camera.position);
            if (cameraDirection.dot(objectDirection) < 0) {
                return null;
            }

            return { x: vector.x, y: vector.y };
        }
        
        // --- LOCAL SAVE/LOAD LOGIC ---
        function saveGame(isAutoSave = false) {
            try {
                const saveData = {
                    characterData,
                    playerStats,
                    gameState: {
                        currentQuestIndex: gameState.currentQuestIndex,
                        quests: gameState.quests
                    },
                    collectedFragments: memoryFragments.map(f => f.collected)
                };
                localStorage.setItem('narrativeQuestSaveData', JSON.stringify(saveData));
                
                if (isAutoSave) {
                    const notification = document.getElementById('autosave-notification');
                    notification.style.opacity = 1;
                    setTimeout(() => {
                        notification.style.opacity = 0;
                    }, 2000);
                } else {
                    showMessage("Game Saved locally!");
                }
            } catch (error) {
                console.error("Error saving game locally: ", error);
                if (!isAutoSave) {
                    showMessage("Failed to save game.");
                }
            }
        }
        
        document.getElementById('save-game-btn').addEventListener('click', () => saveGame(false));

        function loadGame() {
            try {
                const savedJSON = localStorage.getItem('narrativeQuestSaveData');

                if (savedJSON) {
                    const savedData = JSON.parse(savedJSON);
                    characterData = savedData.characterData;
                    playerStats = savedData.playerStats;
                    
                    gameState.quests = savedData.gameState.quests;
                    gameState.currentQuestIndex = savedData.gameState.currentQuestIndex;
                    
                    if (savedData.collectedFragments) {
                        savedData.collectedFragments.forEach((isCollected, index) => {
                            if (memoryFragments[index]) {
                                memoryFragments[index].collected = isCollected;
                                if(isCollected) memoryFragmentMeshes[index].visible = false;
                            }
                        });
                    }
                    
                    hidePanel(characterCreator);
                    uiContainer.style.visibility = 'visible';
                    canMove = true;
                    gameStarted = true;
                    updateQuestLog();
                    showMessage("Game Loaded Successfully!");
                } else {
                    showMessage("No local save file found.");
                    showPanel(startModal);
                }
            } catch (error) {
                console.error("Error loading local save: ", error);
                showMessage("Failed to load game. The save file may be corrupt. Please start a new game.");
                showPanel(characterCreator);
            }
        }

        function checkForSavedGame() {
            return !!localStorage.getItem('narrativeQuestSaveData');
        }

        // --- INITIALIZATION ---
        function main() {
            showPanel(startModal);
            animate(); // Start rendering immediately
            
            const hasSave = checkForSavedGame();
            continueGameBtn.disabled = !hasSave;
        }

        window.onload = function() {
            createMemoryFragments();
            memoryFragmentMeshes.forEach(mesh => {
                mesh.userData.baseY = mesh.position.y;
            });
            main();
        };


        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

