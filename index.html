<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Narrative Quest — Mini-Battle & Gear Update</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Lora', serif;
            background-color: #000;
            color: white;
        }
        canvas { display: block; }
        #ui-container {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; color: #3a2d21;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(253, 246, 227, 0.95);
            border: 4px solid #a87e3a; border-radius: 8px;
            padding: 1rem; pointer-events: all;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-height: 90vh; overflow-y: auto;
            max-width: 90%; width: auto; min-width: 260px;
        }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 100; pointer-events: all;
        }
        .modal-content {
            background-color: #fdf6e3; color: #3a2d21;
            padding: 1.5rem; border-radius: 10px; border: 4px solid #a87e3a;
            width: 90%; max-width: 720px; text-align: center;
            display: flex; flex-direction: column; max-height: 90vh;
        }
        .modal-scroll-content { overflow-y: auto; padding-right: 12px; }
        .creator-option {
            border: 2px solid #d4cba6; cursor: pointer; padding: 12px; border-radius: 8px;
            transition: all 0.2s ease; background-color: #fff; min-height: 90px;
            display: flex; flex-direction: column; justify-content: center;
        }
        .creator-option:hover { background-color: #f0e5c6; }
        .creator-option.selected {
            border-color: #00796b; background-color: #e0f2f1;
            transform: scale(1.03); box-shadow: 0 0 10px rgba(0, 121, 107, 0.5);
        }
        #custom-guardian-input {
            display: none; margin-top: 10px; padding: 10px; width: 100%;
            border: 2px solid #a87e3a; border-radius: 5px; font-family: 'Lora', serif;
        }
        #quest-log { top: 1rem; left: 1rem; width: 270px; transition: all 0.3s ease; }
        #quest-log.minimized { width: auto; padding: 0.5rem 1rem; padding-right: 2rem; }
        #quest-log.minimized h1 { font-size: 1.2rem; margin-bottom: 0; }
        #quest-log p { font-size: 0.9rem; margin-top: 0.5rem; }
        #quest-log.minimized #quest-log-content { display: none; }
        .xp-bar-container {
            background-color: #d4cba6; border-radius: 9999px; overflow: hidden;
            border: 2px solid #a87e3a; padding: 2px; margin-top: 5px;
        }
        .xp-bar {
            background: linear-gradient(90deg, #c89c4a, #f7e08b);
            height: 10px; border-radius: 9999px; transition: width 0.5s ease-in-out;
        }
        .minimize-btn {
            position: absolute; top: 5px; right: 5px; width: 24px; height: 24px;
            padding: 0; font-size: 1.2rem; line-height: 24px; text-align: center;
            margin-top: 0; font-family: monospace; cursor: pointer;
        }
        #dialogue-box { bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 800px; min-height: 100px; display: none; }
        /* Centered panels */
        #writing-challenge, #dynamic-quest-creator, #quest-complete, #journal-panel,
        #monster-created-panel, #combat-panel, #message-box, #prewrite-battle,
        #loot-panel, #gear-panel {
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 760px; display: none;
        }
        #writing-tips-box {
            background: #e0f2f1; border-left: 4px solid #00796b; padding: 10px;
            margin: 12px 0; text-align: left; border-radius: 4px;
        }
        #combat-panel { text-align: center; }
        #combat-log {
            background-color: #fff; border: 2px solid #d4cba6; height: 120px;
            overflow-y: scroll; padding: 10px; margin-top: 15px; text-align: left;
            font-size: 0.9rem; line-height: 1.4;
        }
        #improvement-suggestion {
            background: #fff; border: 2px solid #d4cba6; padding: 15px;
            margin-top: 15px; text-align: left; border-radius: 8px;
        }
        #journal-entries, #achievements-list {
            text-align: left; background-color: #fff; padding: 15px; border-radius: 5px;
            border: 2px solid #d4cba6; min-height: 200px; max-height: 40vh;
            overflow-y: auto; white-space: pre-wrap;
        }
        .journal-entry {
            background-color: #f8f0e0; padding: 15px; border-radius: 8px; margin-bottom: 15px;
            border: 2px solid #d4cba6; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }
        .journal-entry:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .journal-entry h3, .achievement h3 { font-family: 'MedievalSharp', cursive; color: #a87e3a; margin-bottom: 5px; }
        .journal-stage { font-size: 0.9em; color: #5d4037; font-style: italic; margin-bottom: 5px; }
        .journal-entry button {
            position: absolute; top: 10px; right: 10px; background: #00796b; color: white;
            padding: 5px 10px; border-radius: 5px; font-size: 0.8rem; display: none; cursor: pointer;
        }
        .journal-entry:hover button { display: block; }
        .achievement { padding: 10px; margin-bottom: 10px; border-radius: 8px; border: 2px solid #d4cba6; }
        .achievement.unlocked { background-color: #e0f2f1; }
        .achievement.locked { background-color: #f1f1f1; color: #999; }
        .achievement p { font-size: 0.9em; }
        .journal-tabs { display: flex; margin-bottom: -2px; }
        .journal-tab {
            padding: 10px 15px; cursor: pointer; background-color: #d4cba6;
            border: 2px solid #a87e3a; border-bottom: none; border-radius: 8px 8px 0 0;
            margin-right: 5px;
        }
        .journal-tab.active { background-color: #fff; border-bottom: 2px solid #fff; }
        #achievement-notification {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #c89c4a; color: white; padding: 15px 25px; border-radius: 10px;
            font-family: 'MedievalSharp', cursive; font-size: 1.3rem; z-index: 200; opacity: 0;
            transition: opacity 0.5s, bottom 0.5s; pointer-events: none;
        }
        #interact-prompt {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7); color: white; padding: 10px 20px;
            border-radius: 10px; font-size: 1.5rem; font-family: 'MedievalSharp', cursive; display: none;
        }
        #loading-message {
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 10px;
            font-size: 1.2rem; display: none;
        }
        #autosave-notification {
            position: absolute; bottom: 1rem; right: 1rem; background-color: rgba(0,0,0,0.7);
            color: white; padding: 10px 20px; border-radius: 10px; font-size: 1rem;
            opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none;
        }
        h1, h2, h3 { font-family: 'MedievalSharp', cursive; }
        h1 { font-size: 1.8rem; color: #a87e3a; }
        h2 { font-size: 1.4rem; }
        textarea, input[type="text"] {
            width: 100%; background-color: #fff; border: 2px solid #d4cba6; padding: 10px; margin-top: 10px;
            font-family: 'Lora', serif; color: #3a2d21;
        }
        textarea { height: 150px; }
        button {
            background-color: #c89c4a; color: white; padding: 0.9rem 1.2rem; border: none; border-radius: 5px;
            font-family: 'MedievalSharp', cursive; font-size: 1.1rem; cursor: pointer; margin-top: 10px;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #a87e3a; }
        button:disabled { background-color: #888; cursor: not-allowed; }
        #controls-info {
            position: absolute; bottom: 1rem; left: 1rem;
            background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; color: white;
            font-size: 0.9rem;
        }
        #feedback-area { margin-top: 10px; padding: 10px; border-radius: 5px; min-height: 24px; }
        .feedback-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .feedback-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .health-bar-container {
            background-color: #d4cba6; border-radius: 9999px; overflow: hidden; border: 2px solid #a87e3a; padding: 2px;
            margin: 0 auto; width: 80%;
        }
        .health-bar { background: linear-gradient(90deg, #d9534f, #f7d58b); height: 10px; border-radius: 9999px; transition: width 0.5s ease-in-out; }
        .health-bar.player { background: linear-gradient(90deg, #5cb85c, #90ee90); }
        .npc-name {
            position: absolute; background: rgba(0, 0, 0, 0.5); color: white; padding: 4px 8px; border-radius: 4px;
            font-size: 0.8rem; text-align: center; transform: translate(-50%, -50%); pointer-events: none;
            white-space: nowrap; display: none;
        }
        #message-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: #fdf6e3; color: #3a2d21; padding: 20px; border: 4px solid #a87e3a; border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 200; display: none; text-align: center; pointer-events: all;
        }
        .tts-loading-indicator {
            display: inline-block; width: 15px; height: 15px; border: 2px solid #c89c4a; border-top: 2px solid transparent;
            border-radius: 50%; animation: spin 1s linear infinite; margin-left: 10px; vertical-align: middle;
        }
        @keyframes spin { 0%{transform: rotate(0deg);} 100%{transform: rotate(360deg);} }
        /* Action word chips */
        .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
        .chip {
            background: #fff; border: 2px solid #d4cba6; border-radius: 9999px; padding: 6px 10px; font-size: 0.9rem;
            cursor: pointer; user-select: none;
        }
        .chip:hover { background: #f0e5c6; }
        /* Prewrite mini-battle styles */
        .card-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .pick-card {
            background:#fff; border:2px solid #d4cba6; border-radius:8px; padding:10px; min-height:72px; cursor:pointer;
        }
        .pick-card.selected { border-color:#00796b; background:#e0f2f1; }
        .hint { font-size: 0.85rem; color:#35524a; background:#e0f2f1; padding:8px 10px; border-left:4px solid #00796b; border-radius:4px; }
        .loot-card{
            background:#fff; border:2px solid #a87e3a; border-radius:10px; padding:14px; text-align:left;
        }
        .slot-badge{ font-size:0.75rem; background:#e9d8a6; border:1px solid #a87e3a; padding:2px 6px; border-radius:9999px; }
        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; } h2 { font-size: 1.2rem; }
            .ui-panel { padding: 1rem; } button { padding: 0.8rem 1.1rem; font-size: 1rem; }
            #controls-info, #autosave-notification { display: none; }
            .card-grid { grid-template-columns: 1fr; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Lora:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <!-- Start Modal -->
    <div id="start-modal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="start-heading">
        <div class="modal-content">
            <h1 id="start-heading" class="text-3xl mb-4">Welcome, Storyteller</h1>
            <p class="mb-6">Your legend awaits. Will you forge a new path or continue an existing journey?</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <button id="new-game-btn">Forge New Legend</button>
                <button id="continue-game-btn" disabled>Continue Journey</button>
            </div>
        </div>
    </div>

    <!-- Character Creator -->
    <div id="character-creator" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="creator-heading" style="display: none;">
        <div class="modal-content">
            <div class="modal-scroll-content">
                <h1 id="creator-heading" class="text-3xl mb-4">Forge Your Hero</h1>
                <p class="mb-6">Every story needs a beginning. Who is yours?</p>
                <div class="mb-6 text-left">
                    <h2 class="text-xl mb-2">Choose Your Guardian Type</h2>
                    <div id="guardian-type-options" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="creator-option" data-type="Shark Guardian" role="button" tabindex="0"><div class="text-2xl mb-1">🦈</div><div class="font-bold">Shark Guardian</div><p class="text-xs">A mighty warrior of the reefs.</p></div>
                        <div class="creator-option" data-type="Jellyfish Guardian" role="button" tabindex="0"><div class="text-2xl mb-1">✨</div><div class="font-bold">Jellyfish Guardian</div><p class="text-xs">A mystical being of light.</p></div>
                        <div class="creator-option" data-type="Manta Ray Guardian" role="button" tabindex="0"><div class="text-2xl mb-1">🌊</div><div class="font-bold">Manta Ray Guardian</div><p class="text-xs">A graceful navigator of the blue.</p></div>
                        <div class="creator-option" data-type="custom" role="button" tabindex="0"><div class="text-2xl mb-1">✏️</div><div class="font-bold">My Own Guardian</div><p class="text-xs">Describe a hero from imagination.</p></div>
                    </div>
                    <input type="text" id="custom-guardian-input" placeholder="e.g., Sea Turtle, Octopus...">
                </div>
                <div class="mb-6 text-left">
                    <h2 class="text-xl mb-2">Choose Your Realm</h2>
                    <div id="guardian-domain-options" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="creator-option" data-domain="Coral Reef" role="button" tabindex="0"><div class="text-2xl mb-1">🐠</div><p class="text-xs">Coral Reef</p></div>
                        <div class="creator-option" data-domain="Deep Trench" role="button" tabindex="0"><div class="text-2xl mb-1">🦑</div><p class="text-xs">Deep Trench</p></div>
                        <div class="creator-option" data-domain="Kelp Forest" role="button" tabindex="0"><div class="text-2xl mb-1">🌿</div><p class="text-xs">Kelp Forest</p></div>
                    </div>
                </div>
            </div>
            <button id="start-game-btn" class="mt-4">Begin Your Legend</button>
        </div>
    </div>

    <!-- UI Container -->
    <div id="ui-container" style="visibility: hidden;">
        <!-- Quest Log -->
        <div id="quest-log" class="ui-panel" role="region" aria-labelledby="quest-heading">
            <button id="minimize-quest-log" class="minimize-btn" aria-label="Minimize quest log">-</button>
            <h1 id="quest-heading">Quest Log</h1>
            <div id="quest-log-content">
                <p id="player-level-info" class="font-bold">Level 1 Guardian</p>
                <div class="xp-bar-container"><div id="xp-bar" class="xp-bar"></div></div>
                <p class="mt-2 text-sm">Attack: <span id="player-attack"></span></p>
                <p class="text-sm">Health: <span id="player-health"></span></p>
                <p class="text-sm">Speed: <span id="player-speed"></span></p>
                <p id="quest-title" class="mt-3">No active quest.</p>
                <p id="quest-objective">The Village Elder seems troubled. Perhaps they have a story to tell.</p>
                <div class="flex flex-col gap-2 mt-3">
                    <button id="open-journal-btn" class="text-sm p-1">Open Journal</button>
                    <button id="open-gear-btn" class="text-sm p-1">Gear & Equipment</button>
                    <button id="save-game-btn" class="text-sm p-1">Save Game</button>
                </div>
            </div>
        </div>

        <!-- Dialogue -->
        <div id="dialogue-box" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="dialogue-title">
            <h2 id="dialogue-title">Village Elder</h2>
            <p id="dialogue-text">Welcome, hero. A shadow has fallen upon our waters, and we need your strength.</p>
            <div class="flex justify-center"><button id="dialogue-button">Accept Quest</button></div>
        </div>

        <!-- Prewrite Mini-Battle Gate -->
        <div id="prewrite-battle" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="prewrite-title">
            <h2 id="prewrite-title">Mini-Battle: Plan Your Move</h2>
            <p class="mb-2">Before you write, prepare a quick plan. Win this “battle of ideas” to unlock the next writing part.</p>
            <div class="hint mb-3"><b>Doing word = action word.</b> Choose one below and use it in a strong sentence.</div>

            <div>
                <h3 class="mb-1">Pick an action word</h3>
                <div id="pre-action-bank" class="chips"></div>
            </div>
            <div class="mt-3">
                <h3 class="mb-1">Choose your focus</h3>
                <div class="card-grid">
                    <div class="pick-card" data-group="who">Hero: <b><span id="focus-who"></span></b></div>
                    <div class="pick-card" data-group="goal">Goal: <b><span id="focus-goal"></span></b></div>
                    <div class="pick-card" data-group="obstacle">Obstacle: <b><span id="focus-obstacle"></span></b></div>
                </div>
            </div>
            <div class="mt-3">
                <label for="prewrite-sentence" class="font-bold">Your battle sentence</label>
                <input id="prewrite-sentence" type="text" placeholder="I ___ through the toxic fog to reach the lighthouse." />
                <div class="text-xs mt-1 text-gray-700">Tip: Use your chosen action word and mention the goal or obstacle.</div>
            </div>
            <div class="flex gap-2 mt-3 justify-center">
                <button id="prewrite-roll-btn" class="text-sm">Shuffle Focus</button>
                <button id="prewrite-submit-btn">Win the Mini-Battle</button>
            </div>
            <div id="prewrite-feedback" class="mt-2"></div>
        </div>

        <!-- Writing Challenge -->
        <div id="writing-challenge" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="challenge-title">
            <h2 id="narrative-stage"></h2>
            <h3 id="challenge-title">Challenge: Loading...</h3>
            <p id="challenge-prompt">Loading...</p>

            <div id="writing-tips-box" role="region" aria-labelledby="tips-heading">
                <h3 id="tips-heading" class="text-lg font-bold">Writing Tips</h3>
                <p id="current-tips"></p>
                <div class="mt-2 text-sm text-gray-800"><b>Action word = doing word.</b> Try one from the bank below.</div>
            </div>

            <div>
                <div class="font-semibold">Action Word Bank (click to insert)</div>
                <div id="action-word-bank" class="chips"></div>
            </div>

            <textarea id="writing-input" placeholder="My Guardian surges through the waves, gripping the shattered mast as lightning stitches the sky..."></textarea>
            <div id="feedback-area" aria-live="polite"></div>
            <button id="writing-submit">Weave Your Tale</button>
        </div>

        <!-- Dynamic Quest Creator -->
        <div id="dynamic-quest-creator" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="dynamic-quest-heading">
            <h1 id="dynamic-quest-heading" class="text-2xl">The Storyteller's Choice</h1>
            <p class="my-4">Write a short paragraph describing what happens next. Does a great beast rise? A cursed artifact whisper? Shape the next chapter.</p>
            <textarea id="dynamic-quest-input" placeholder="As the oily slick parts, a colossal shape begins to rise from the depths..."></textarea>
            <button id="dynamic-quest-submit">Shape the Climax</button>
        </div>

        <!-- Monster Created Panel -->
        <div id="monster-created-panel" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="monster-heading" style="display: none;">
            <div class="modal-content text-center">
                <h1 id="monster-heading" class="text-3xl mb-4 text-red-600">From your words, a challenge emerges...</h1>
                <p class="mb-6">Your description has summoned a new foe to the surface!</p>
                <div class="p-6 rounded-lg border-2 border-red-800 bg-red-50 mb-6">
                    <h2 id="monster-name" class="text-2xl font-bold my-2 text-red-800"></h2>
                    <p id="monster-description" class="my-4 text-red-700"></p>
                </div>
                <button id="start-combat-btn" class="bg-red-500 hover:bg-red-700">Continue</button>
            </div>
        </div>

        <!-- Quest Complete -->
        <div id="quest-complete" class="ui-panel text-center" role="dialog" aria-modal="true" aria-labelledby="quest-complete-heading">
            <h1 id="quest-complete-heading" class="text-2xl text-green-600">A Chapter Closes</h1>
            <p id="reward-text" class="my-4 text-lg"></p>
            <div id="improvement-suggestion"></div>
            <div class="flex justify-center gap-4 flex-wrap">
                <button id="try-again-btn">Try Again Myself</button>
                <button id="continue-questing-btn">Continue Questing</button>
            </div>
        </div>

        <!-- Combat Panel -->
        <div id="combat-panel" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="combat-title">
            <h2 id="combat-title"></h2>
            <p class="mt-4">Your Health:</p>
            <div class="health-bar-container" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" aria-label="Player health">
                <div id="player-health-bar" class="health-bar player"></div>
            </div>
            <p class="mt-2">Enemy Health:</p>
            <div class="health-bar-container" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" aria-label="Enemy health">
                <div id="enemy-health-bar" class="health-bar"></div>
            </div>
            <div id="combat-log" class="mt-4"></div>
            <p id="combat-prompt" class="mt-4 font-bold"></p>
            <div class="flex gap-2 mt-2">
                <input type="text" id="combat-writing-input" class="flex-grow" placeholder="Describe your action...">
                <button id="combat-submit-btn" class="p-2 text-base">Attack!</button>
            </div>
            <button id="special-move-btn" class="mt-2 text-sm p-1 bg-purple-600 hover:bg-purple-800">Use Simile Power (Lvl 2)</button>
        </div>

        <!-- Journal -->
        <div id="journal-panel" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="journal-heading">
            <h1 id="journal-heading" class="text-2xl">Story Journal</h1>
            <div class="journal-tabs">
                <div id="story-tab" class="journal-tab active">Story</div>
                <div id="achievements-tab" class="journal-tab">Achievements</div>
            </div>
            <div id="journal-entries"></div>
            <div id="achievements-list" style="display: none;"></div>
            <div class="flex justify-center gap-4 mt-4">
                <button id="copy-journal-btn">Copy Story</button>
                <button id="close-journal-btn">Close</button>
            </div>
        </div>

        <!-- Gear Panel -->
        <div id="gear-panel" class="ui-panel" role="dialog" aria-modal="true" aria-labelledby="gear-heading">
            <h1 id="gear-heading" class="text-2xl">Gear & Equipment</h1>
            <div id="equipped-readout" class="mb-3 text-sm"></div>
            <div id="inventory-list" class="space-y-2"></div>
            <div class="flex justify-center gap-3 mt-3"><button id="close-gear-btn">Close</button></div>
        </div>

        <!-- Loot Modal -->
        <div id="loot-panel" class="ui-panel text-center" role="dialog" aria-modal="true" aria-labelledby="loot-heading">
            <h2 id="loot-heading" class="text-xl text-green-700 mb-2">You found gear!</h2>
            <div id="loot-card" class="loot-card"></div>
            <div class="flex justify-center gap-2 mt-3">
                <button id="loot-equip-btn">Equip Now</button>
                <button id="loot-close-btn">Keep</button>
            </div>
        </div>

        <div id="interact-prompt" aria-hidden="true">Press [E] to Interact</div>
        <div id="loading-message" role="status" aria-live="polite">The world holds its breath...</div>

        <div id="elder-name" class="npc-name">Village Elder</div>
        <div id="fisherman-name" class="npc-name">Fisherman</div>
        <div id="sage-name" class="npc-name">Sage of the Tides</div>
        <div id="war-torn-elder-name" class="npc-name">War-Torn Elder</div>

        <div id="controls-info" aria-hidden="true">
            <b>Controls:</b><br><b>W, A, S, D:</b> Move<br><b>E:</b> Interact
        </div>
        <div id="autosave-notification">Auto-saving...</div>
        <div id="achievement-notification">Achievement Unlocked!</div>
    </div>

    <div id="message-box" class="ui-panel" role="alertdialog" aria-modal="true" aria-labelledby="message-text">
        <p id="message-text">Message goes here.</p>
        <button id="message-button">OK</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- GEMINI API SETUP ---
        const LLM_API_URL = '/gemini';
        const TTS_API_URL = '/gemini-tts';

        // --- GAME STATE & CHARACTER DATA ---
        let characterData = { type: null, domain: null, customName: "" };

        let playerStats = {
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            baseHealth: 100,
            baseDamage: 10,
            journal: [],
            achievements: {},
            collectedFragments: 0,
            inventory: {}, // map id -> { owned, equipped }
            equipmentSlots: { weapon: null, armor: null, trinket: null }
        };

        // Movement
        let baseMoveSpeed = 8.0;
        let moveSpeed = baseMoveSpeed;

        let lastSubmission = "";
        let lastValidationResponse = null;
        let currentMonsterName = "";
        let currentMonsterDescription = "";
        let currentMonsterHealth = 100;

        // --- World Atmosphere Transition ---
        let isTransitioningAtmosphere = false;
        let atmosphereTransitionDuration = 4000; // 4 seconds
        let atmosphereTransitionStart = 0;
        const startAtmo = {};
        const targetAtmo = {};

        // Plot mountain
        const narrativeStages = ["Exposition", "Rising Action", "Climax", "Falling Action", "Resolution"];
        const writingTips = {
            "Exposition": "Introduce who, where, and a clear goal. Use doing words (action words).",
            "Rising Action": "Add challenges. Chain cause → effect with strong doing words.",
            "Climax": "Make the biggest moment vivid. Short, punchy, active sentences.",
            "Falling Action": "Calm the pace. Show quick results of the climax—keep it clear.",
            "Resolution": "Show the new normal. What changed? End with a precise, active image."
        };

        const achievements = {
            "STORY_BEGINS": { title: "The Story Begins", description: "Complete your first writing challenge.", unlocked: false },
            "FIRST_VICTORY": { title: "First Victory", description: "Win your first narrative combat.", unlocked: false },
            "LOREMASTER": { title: "Loremaster", description: "Collect all the memory fragments.", unlocked: false },
            "WORD_WEAVER": { title: "Word Weaver", description: "Use a special move in combat.", unlocked: false },
            "SAVIOR": { title: "Savior of the Lands", description: "Complete all quests.", unlocked: false },
            "FIRST_GEAR": { title: "First Gear", description: "Obtain your first piece of gear.", unlocked: false }
        };

        // Memory fragments
        const memoryFragments = [
            { pos: new THREE.Vector3(15, 2, 15), text: "Lore: The ancient stones whisper of a time when the sky and sea were one, before the Great Separation.", collected: false },
            { pos: new THREE.Vector3(-10, 2, -20), text: "Writing Tip: Use strong doing words! Instead of 'walked,' try 'stomped,' 'glided,' or 'crept.'", collected: false },
            { pos: new THREE.Vector3(20, 2, -10), text: "Lore: It is said the first Guardian was born from a tear of the ocean itself, a being of pure will.", collected: false },
            { pos: new THREE.Vector3(-25, 2, 25), text: "Writing Tip: Sensory details bring a world to life. What can you smell or hear?", collected: false },
        ];
        let memoryFragmentMeshes = [];

        // ===== Classroom Safety Config =====
        const SAFETY = { maxViolence: 1, maxGore: 1, slangPolicy: "nudge" };
        const DENYLIST = [
            /\\b(?:nigg\\w+)\\b/i,
            /\\b(?:suicide|kill myself)\\b/i,
            /\\b(?:address\\s*\\d{2,}|phone\\s*\\d{6,})\\b/i
        ];

        // Action word bank (used in mini-battle + writing)
        const ACTION_WORDS = [
            "dash","charge","slice","surge","vault","weave","blast","grip","launch",
            "sprint","anchor","shield","hurl","ignite","freeze","sweep","pierce","dodge"
        ];

        // Prewrite focus pools
        const FOCUS = {
            who: ["my guardian","the elder","the fisherman","the Sage","the village"],
            goal: ["protect the village","find the source","calm the tides","reach the lighthouse"],
            obstacle: ["toxic fog","ravenous current","whispering shadows","shattered reef"]
        };

        // Gear items
        const ITEMS = [
            { id:"quill_clarity", name:"Quill of Clarity", slot:"weapon",
              desc:"+4 Attack. Your verbs cut cleaner.", bonuses:{damage:4} },
            { id:"cloak_coherence", name:"Cloak of Coherence", slot:"armor",
              desc:"+20 Health. Ideas hold together.", bonuses:{health:20} },
            { id:"boots_pace", name:"Boots of Pace", slot:"trinket",
              desc:"+20% Move Speed. Keep the story moving.", bonuses:{speed:0.2} },
            { id:"ring_focus", name:"Ring of Focus", slot:"trinket",
              desc:"+2 Attack. Aim your sentences.", bonuses:{damage:2} },
            { id:"shield_metaphor", name:"Shield of Metaphor", slot:"armor",
              desc:"+10 Health. Imagery protects you.", bonuses:{health:10} }
        ];

        // Helper: get item by id
        const getItem = (id)=>ITEMS.find(i=>i.id===id);

        // ===== TTS helpers (kept from previous build) =====
        const pcmToWav = (pcmData, sampleRate) => {
            const numChannels = 1; const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const writeString=(view, off, str)=>{ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); };
            writeString(view,0,'RIFF'); view.setUint32(4, 36 + pcmData.byteLength, true); writeString(view,8,'WAVE');
            writeString(view,12,'fmt '); view.setUint32(16,16,true); view.setUint16(20,1,true);
            view.setUint16(22,numChannels,true); view.setUint32(24,sampleRate,true);
            view.setUint32(28,byteRate,true); view.setUint16(32,blockAlign,true); view.setUint16(34,16,true);
            writeString(view,36,'data'); view.setUint32(40, pcmData.byteLength, true);
            new Int16Array(buffer, 44).set(pcmData);
            return new Blob([view], { type: 'audio/wav' });
        };
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64); const len = binaryString.length; const bytes = new Uint8Array(len);
            for (let i=0;i<len;i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes.buffer;
        };

        async function callProxyAPI(apiUrl, payload) {
            try {
                const response = await fetch(apiUrl, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("API call via proxy failed:", response.status, errorText);
                    if (response.status === 404) showMessage("The AI API endpoint was not found. Please check the server setup.");
                    else if (response.status === 500 && errorText.includes("API key not configured")) showMessage("AI features are not configured on the server. Please contact the administrator.");
                    else showMessage("An unexpected server error occurred. Please try again later.");
                    return null;
                }
                const data = await response.json();
                if (data.candidates && data.candidates[0].finishReason === 'SAFETY') {
                    showMessage("Your writing was blocked for safety reasons. Please revise and try again.");
                    return null;
                }
                return data;
            } catch (error) {
                console.error("Error calling proxy API:", error);
                if (error instanceof SyntaxError) showMessage("Received an invalid response from the server. The AI service might be down.");
                else showMessage("A network error occurred. Please check your connection and try again.");
                return null;
            }
        }

        async function callGeminiForText(systemPrompt, userPrompt, schema) {
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: { responseMimeType: "application/json", responseSchema: schema }
            };
            const result = await callProxyAPI(LLM_API_URL, payload);
            if (!result || !result.candidates || !result.candidates[0].content) return null;
            try {
                const textResponse = result.candidates[0].content.parts[0].text;
                return JSON.parse(textResponse);
            } catch (error) {
                console.error("Failed to parse JSON from API:", error);
                return null;
            }
        }

        async function callGeminiClassifier(text) {
            const systemPrompt = `You are a Year 7 classroom safety checker. Analyze the student's text and return strict JSON.
            Definitions:
            - inappropriate = true if sexual content, hateful/harassing language, self-harm, explicit illegal activity, or doxxing/PII.
            - violence_severity: 0=none, 1=mild/cartoon peril (non-graphic), 2=moderate (injury, weapons, minimal blood detail), 3=graphic/gory.
            - gore_severity: 0=none, 1=implied blood, 2=blood/injury described, 3=graphic gore.
            - slang_flags: list any low-value meme/slang that reduces academic quality.
            - includes_brainrot: true if "brain rot" or close variant appears.
            - rewrite_suggestion: one short, school-safe tip (<=20 words) that preserves intent but removes issues.
            Do not echo slurs or sexual content in your JSON.`.trim();

            const schema = {
                type: "OBJECT",
                additionalProperties: false,
                properties: {
                    inappropriate: { type: "BOOLEAN" },
                    reasons: { type: "ARRAY", items: { type: "STRING" } },
                    violence_severity: { type: "NUMBER" },
                    gore_severity: { type: "NUMBER" },
                    slang_flags: { type: "ARRAY", items: { type: "STRING" } },
                    includes_brainrot: { type: "BOOLEAN" },
                    rewrite_suggestion: { type: "STRING" }
                }
            };

            const result = await callGeminiForText(systemPrompt, text, schema);
            return result || { inappropriate: false, reasons: [], violence_severity: 0, gore_severity: 0, slang_flags: [], includes_brainrot: false, rewrite_suggestion: "Use precise verbs and non-graphic detail." };
        }

        async function screenTextForClassroom(text) {
            for (const re of DENYLIST) {
                if (re.test(text)) {
                    return { allowed: false, nudge: false, message: "This includes content we can’t use at school. Please rewrite with school-appropriate language." };
                }
            }
            const c = await callGeminiClassifier(text);
            if (!c) return { allowed: false, nudge: false, message: "Could not analyze text. Please try again." };
            const violence = Number(c.violence_severity || 0);
            const gore = Number(c.gore_severity || 0);
            const slangDetected = (c.includes_brainrot === true) || (Array.isArray(c.slang_flags) && c.slang_flags.length > 0);
            const mustBlock = Boolean(c.inappropriate) || violence > SAFETY.maxViolence || gore > SAFETY.maxGore;
            if (mustBlock) return { allowed: false, nudge: false, message: c.rewrite_suggestion || "Please rewrite without graphic detail, slang, or personal info." };
            const nudge = (slangDetected && SAFETY.slangPolicy === "nudge") || violence === 1 || gore === 1;
            if (nudge) return { allowed: true, nudge: true, tip: c.rewrite_suggestion || "Replace slang with clear description; keep any danger non-graphic." };
            return { allowed: true, nudge: false };
        }

        async function callGeminiForQuestGeneration(writing) {
            const systemPrompt = `You are a Game Master for a narrative RPG. The player has described the next event in their story. Your job is to turn that description into a quest. Analyze the text and generate a JSON object.
            - quest_title: A title for this new quest.
            - quest_type: If the player described a monster/fight, return "writing_combat". Otherwise, return "writing".
            - npc_to_visit: The most logical existing NPC to start this quest (Village Elder, Fisherman, Sage of the Tides, War-Torn Elder).
            - objective: A short, clear objective for the player's quest log.
            - writing_prompt: A creative writing prompt for the climax of the story.
            - monster_name: If it's a combat quest, the name of the monster described.
            - monster_description: If it's a combat quest, a short description of the monster.`;

            const schema = {
                type: "OBJECT",
                properties: {
                    "quest_title": { "type": "STRING" },
                    "quest_type": { "type": "STRING" },
                    "npc_to_visit": { "type": "STRING" },
                    "objective": { "type": "STRING" },
                    "writing_prompt": { "type": "STRING" },
                    "monster_name": { "type": "STRING" },
                    "monster_description": { "type": "STRING" }
                }
            };
            return await callGeminiForText(systemPrompt, writing, schema);
        }

        async function callGeminiForAtmosphere(writing) {
            const systemPrompt = `Analyze the following text and extract its visual atmosphere. Provide your answer as a JSON object. The colors should be hex codes. Example: { "skyColor": "#333333", "fogColor": "#454545", "groundColor": "#5a6a5a", "particleColor": "#cccccc", "atmosphere": "gloomy" }`;
            const schema = { type:"OBJECT", properties:{ skyColor:{type:"STRING"}, fogColor:{type:"STRING"}, groundColor:{type:"STRING"}, particleColor:{type:"STRING"}, atmosphere:{type:"STRING"} } };
            const userPrompt = `Based on this text, what is the visual atmosphere?\\n\\n${writing}`;
            return await callGeminiForText(systemPrompt, userPrompt, schema);
        }

        async function callGeminiForTTS(text, voiceName = "Kore") {
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } } }
                }
            };
            const result = await callProxyAPI(TTS_API_URL, payload);
            if (!result) return null;
            const part = result.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;
            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const sampleRate = parseInt(mimeType.match(/rate=(\\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                return URL.createObjectURL(wavBlob);
            }
            return null;
        }

        async function callGeminiForJournalExpansion(text) {
            const payload = { contents: [{ parts: [{ text: \`Expand the following short story entry into a more detailed, cinematic paragraph suitable for a fantasy RPG game:\\n\\n\${text}\` }] }], generationConfig: { responseMimeType: "text/plain" } };
            const result = await callProxyAPI(LLM_API_URL, payload);
            return result?.candidates?.[0]?.content?.parts?.[0]?.text;
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Camera (Top-down Ortho)
        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 30;
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2, 1, 1000
        );
        camera.position.set(0, 50, 0);
        camera.lookAt(0, 0, 0);
        scene.add(camera);

        // Lighting
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.8);
        scene.add(hemisphereLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-30, 50, -30);
        dirLight.castShadow = true; dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Character factory
        function createCharacterModel(color) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.8, 1.6, 4, 8), new THREE.MeshStandardMaterial({ color }));
            body.castShadow = true; body.receiveShadow = true; body.position.y = 1.8; group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshStandardMaterial({ color }));
            head.position.y = 3.5; head.castShadow = true; group.add(head);
            return group;
        }

        // Player & NPCs
        const player = createCharacterModel(0xffff00); player.position.set(0, 0, 20); scene.add(player);
        const villageElder = createCharacterModel(0x0000ff); villageElder.position.set(0, 0, 0); villageElder.name = "Village Elder"; scene.add(villageElder);
        const fisherman = createCharacterModel(0x808080); fisherman.position.set(-15, 0, -15); fisherman.name = "Fisherman"; scene.add(fisherman);
        const sageOfTheTides = createCharacterModel(0x008080); sageOfTheTides.position.set(10, 0, -25); sageOfTheTides.name = "Sage of the Tides"; scene.add(sageOfTheTides);
        const warTornElder = createCharacterModel(0x5a2e2e); warTornElder.position.set(-20, 0, 10); warTornElder.name = "War-Torn Elder"; scene.add(warTornElder);

        // Enemy (placeholder mesh)
        const pollutionElemental = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true }));
        pollutionElemental.position.set(-25, 2, 0); pollutionElemental.name = "Pollution Elemental"; pollutionElemental.castShadow = true; pollutionElemental.visible = false; scene.add(pollutionElemental);
        let createdMonster = { object: pollutionElemental, name: "Pollution Elemental", description: "a fearsome elemental born of plastic and sludge", baseHealth: 100 };

        // World ground & road
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4F7942 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

        function createGravelTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#966F33'; ctx.fillRect(0,0,256,256);
            for (let i = 0; i < 10000; i++) {
                const x = Math.random()*256, y = Math.random()*256, r = Math.random()*1.5;
                const g = Math.floor(Math.random()*100)+80; const color = \`rgb(\${g}, \${g-10}, \${g-20})\`;
                ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
            }
            const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(80,5); return texture;
        }
        const roadPoints = [ new THREE.Vector3(0,0,25), new THREE.Vector3(5,0,15), new THREE.Vector3(0,0,5), new THREE.Vector3(-5,0,-5), new THREE.Vector3(-15,0,-15), new THREE.Vector3(-20,0,-5), new THREE.Vector3(-25,0,0), new THREE.Vector3(-20,0,10), new THREE.Vector3(10,0,-25) ];
        const roadCurve = new THREE.CatmullRomCurve3(roadPoints);
        const roadGeometry = new THREE.TubeGeometry(roadCurve, 128, 2.5, 8, false);
        const roadMaterial = new THREE.MeshStandardMaterial({ map: createGravelTexture() });
        const road = new THREE.Mesh(roadGeometry, roadMaterial); road.scale.y = 0.05; road.position.y = 0.1; road.receiveShadow = true; scene.add(road);

        // Instanced trees, rocks
        const treeCount = 100;
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 8, 8);
        const leavesGeometry = new THREE.IcosahedronGeometry(4, 0);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22, flatShading: true });
        const instancedTrunks = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, treeCount);
        const instancedLeaves = new THREE.InstancedMesh(leavesGeometry, leavesMaterial, treeCount);
        instancedTrunks.castShadow = true; instancedLeaves.castShadow = true;
        const dummy = new THREE.Object3D();
        for (let i=0;i<treeCount;i++) {
            const x=(Math.random()-0.5)*400, z=(Math.random()-0.5)*400;
            dummy.position.set(x, 4, z); dummy.rotation.y = Math.random()*Math.PI*2; const s = Math.random()*0.5+0.75; dummy.scale.set(s,s,s); dummy.updateMatrix();
            instancedTrunks.setMatrixAt(i, dummy.matrix);
            dummy.position.y = 10; dummy.updateMatrix(); instancedLeaves.setMatrixAt(i, dummy.matrix);
        }
        scene.add(instancedTrunks); scene.add(instancedLeaves);

        const rockCount = 50;
        const rockGeometry = new THREE.IcosahedronGeometry(1, 0);
        const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, flatShading: true });
        const instancedRocks = new THREE.InstancedMesh(rockGeometry, rockMaterial, rockCount);
        for (let i=0;i<rockCount;i++){
            dummy.position.set((Math.random()-0.5)*400, Math.random()*2, (Math.random()-0.5)*400);
            dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            const s = Math.random()*2+1; dummy.scale.set(s,s,s); dummy.updateMatrix();
            instancedRocks.setMatrixAt(i, dummy.matrix);
        }
        scene.add(instancedRocks);

        // Ambient particles
        const particleCount = 500;
        const particlesGeometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount*3);
        for (let i=0;i<particleCount*3;i++) posArray[i]=(Math.random()-0.5)*200;
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particleMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0xeeeeff });
        const particleMesh = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleMesh);

        // --- GAME LOGIC FLAGS ---
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, interactKeyPressed=false;
        const clock = new THREE.Clock();
        let canMove = true; let gameStarted = false;
        const gameState = {
            currentQuestIndex: 0,
            quests: [
                { id: "AWAKENING", type: "writing", title: "A Stranger's Arrival", objective: "Introduce yourself to the Village Elder.", writingPrompt: "The Village Elder studies you. 'Who are you, and why have you come?' Describe your hero (appearance, personality, and a clear goal).", isComplete: false, npc: "Village Elder", rewardXP: 100, prewriteCleared:false },
                { id: "RISING_ACTION", type: "writing", title: "The Spreading Sickness", objective: "Find the Fisherman to learn about the growing blight.", writingPrompt: "The Fisherman points to the horizon. 'It started small,' he says, 'but now... it breathes.' Describe the monstrous slick of pollution using strong doing words and sensory detail.", isComplete: false, npc: "Fisherman", rewardXP: 150, prewriteCleared:false }
            ],
            canInteractWith: null,
            isCombatActive: false
        };

        // --- COMBAT STATE ---
        let combatState = { playerHP: 100, enemyHP: 100, playerDamage: 10, enemyDamage: 5, isPlayerTurn: true, useSpecialMove: false };

        // --- UI ELEMENTS ---
        const uiContainer = document.getElementById('ui-container');
        const characterCreator = document.getElementById('character-creator');
        const startGameBtn = document.getElementById('start-game-btn');
        const guardianTypeOptions = document.getElementById('guardian-type-options');
        const customGuardianInput = document.getElementById('custom-guardian-input');
        const guardianDomainOptions = document.getElementById('guardian-domain-options');
        const startModal = document.getElementById('start-modal');
        const continueGameBtn = document.getElementById('continue-game-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        const questLog = document.getElementById('quest-log');
        const questTitle = document.getElementById('quest-title');
        const questObjective = document.getElementById('quest-objective');
        const playerLevelInfo = document.getElementById('player-level-info');
        const xpBar = document.getElementById('xp-bar');
        const playerAttack = document.getElementById('player-attack');
        const playerHealth = document.getElementById('player-health');
        const playerSpeed = document.getElementById('player-speed');

        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueTitle = document.getElementById('dialogue-title');
        const dialogueText = document.getElementById('dialogue-text');
        const dialogueButton = document.getElementById('dialogue-button');

        const prewriteBattle = document.getElementById('prewrite-battle');
        const preActionBank = document.getElementById('pre-action-bank');
        const prewriteRollBtn = document.getElementById('prewrite-roll-btn');
        const prewriteSubmitBtn = document.getElementById('prewrite-submit-btn');
        const prewriteSentence = document.getElementById('prewrite-sentence');
        const prewriteFeedback = document.getElementById('prewrite-feedback');
        const focusWho = document.getElementById('focus-who');
        const focusGoal = document.getElementById('focus-goal');
        const focusObstacle = document.getElementById('focus-obstacle');

        const writingChallenge = document.getElementById('writing-challenge');
        const narrativeStage = document.getElementById('narrative-stage');
        const challengeTitle = document.getElementById('challenge-title');
        const challengePrompt = document.getElementById('challenge-prompt');
        const writingInput = document.getElementById('writing-input');
        const writingSubmit = document.getElementById('writing-submit');
        const writingTipsBox = document.getElementById('writing-tips-box');
        const currentTips = document.getElementById('current-tips');
        const actionWordBank = document.getElementById('action-word-bank');

        const dynamicQuestCreator = document.getElementById('dynamic-quest-creator');
        const dynamicQuestInput = document.getElementById('dynamic-quest-input');
        const dynamicQuestSubmit = document.getElementById('dynamic-quest-submit');

        const questComplete = document.getElementById('quest-complete');
        const rewardText = document.getElementById('reward-text');
        const continueQuestingBtn = document.getElementById('continue-questing-btn');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const improvementSuggestion = document.getElementById('improvement-suggestion');

        const monsterCreatedPanel = document.getElementById('monster-created-panel');
        const monsterName = document.getElementById('monster-name');
        const monsterDescription = document.getElementById('monster-description');
        const startCombatBtn = document.getElementById('start-combat-btn');

        const combatPanel = document.getElementById('combat-panel');
        const combatTitle = document.getElementById('combat-title');
        const playerHealthBar = document.getElementById('player-health-bar');
        const enemyHealthBar = document.getElementById('enemy-health-bar');
        const combatLog = document.getElementById('combat-log');
        const combatPrompt = document.getElementById('combat-prompt');
        const combatWritingInput = document.getElementById('combat-writing-input');
        const combatSubmitBtn = document.getElementById('combat-submit-btn');
        const specialMoveBtn = document.getElementById('special-move-btn');

        const journalPanel = document.getElementById('journal-panel');
        const journalEntries = document.getElementById('journal-entries');
        const achievementsList = document.getElementById('achievements-list');
        const storyTab = document.getElementById('story-tab');
        const achievementsTab = document.getElementById('achievements-tab');
        const openJournalBtn = document.getElementById('open-journal-btn');
        const closeJournalBtn = document.getElementById('close-journal-btn');
        const copyJournalBtn = document.getElementById('copy-journal-btn');

        const openGearBtn = document.getElementById('open-gear-btn');
        const gearPanel = document.getElementById('gear-panel');
        const inventoryList = document.getElementById('inventory-list');
        const equippedReadout = document.getElementById('equipped-readout');
        const closeGearBtn = document.getElementById('close-gear-btn');

        const lootPanel = document.getElementById('loot-panel');
        const lootCard = document.getElementById('loot-card');
        const lootEquipBtn = document.getElementById('loot-equip-btn');
        const lootCloseBtn = document.getElementById('loot-close-btn');

        const interactPrompt = document.getElementById('interact-prompt');
        const loadingMessage = document.getElementById('loading-message');
        const feedbackArea = document.getElementById('feedback-area');

        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');

        // --- UI helpers ---
        function showPanel(panel, focusElement = null) {
            panel.style.display = panel.classList.contains('modal-backdrop') ? 'flex' : 'block';
            if (focusElement) focusElement.focus();
        }
        function hidePanel(panel) { panel.style.display = 'none'; }

        function updateQuestLog() {
            const q = gameState.quests[gameState.currentQuestIndex];
            if (q) { questTitle.textContent = q.title; questObjective.textContent = q.objective; }
            else { questTitle.textContent = "All quests complete!"; questObjective.textContent = "You have brought peace to the lands."; }
            playerLevelInfo.textContent = \`Level \${playerStats.level} Guardian\`;
            xpBar.style.width = \`\${(playerStats.xp / playerStats.xpToNextLevel) * 100}%\`;
            playerAttack.textContent = playerStats.baseDamage;
            playerHealth.textContent = playerStats.baseHealth;
            playerSpeed.textContent = (moveSpeed/baseMoveSpeed).toFixed(2) + "×";
        }

        function unlockAchievement(id) {
            if (!achievements[id] || playerStats.achievements[id]) return;
            playerStats.achievements[id] = true; achievements[id].unlocked = true;
            const notification = document.getElementById('achievement-notification');
            notification.textContent = \`Achievement Unlocked: \${achievements[id].title}\`;
            notification.style.bottom = '20px'; notification.style.opacity = 1;
            setTimeout(()=>{ notification.style.bottom = '-100px'; notification.style.opacity = 0; }, 3000);
        }

        // === Action Word bank renderers ===
        function renderActionBank(container, onPick){
            container.innerHTML = "";
            ACTION_WORDS.forEach(w => {
                const span = document.createElement('span');
                span.className = 'chip'; span.textContent = w;
                span.addEventListener('click', ()=> onPick(w));
                container.appendChild(span);
            });
        }

        // === Mini-Battle: Prewrite Gate ===
        let chosenActionWord = null;
        let focusSelection = { who:"", goal:"", obstacle:"" };

        function shuffleFocus() {
            focusSelection.who = FOCUS.who[Math.floor(Math.random()*FOCUS.who.length)];
            focusSelection.goal = FOCUS.goal[Math.floor(Math.random()*FOCUS.goal.length)];
            focusSelection.obstacle = FOCUS.obstacle[Math.floor(Math.random()*FOCUS.obstacle.length)];
            focusWho.textContent = focusSelection.who;
            focusGoal.textContent = focusSelection.goal;
            focusObstacle.textContent = focusSelection.obstacle;
        }

        function showPrewriteBattle() {
            renderActionBank(preActionBank, (w)=>{ chosenActionWord = w; highlightPreActionWord(w); });
            shuffleFocus(); prewriteSentence.value = "";
            prewriteFeedback.innerHTML = "";
            chosenActionWord = ACTION_WORDS[Math.floor(Math.random()*ACTION_WORDS.length)];
            highlightPreActionWord(chosenActionWord);
            showPanel(prewriteBattle, prewriteSentence);
        }

        function highlightPreActionWord(word){
            [...preActionBank.querySelectorAll('.chip')].forEach(ch => {
                ch.style.outline = (ch.textContent === word) ? "3px solid #00796b" : "none";
            });
        }

        async function resolvePrewriteBattle() {
            const sentence = prewriteSentence.value.trim();
            if (sentence.length < 8) {
                prewriteFeedback.innerHTML = '<div class="feedback-error">Write one clear sentence (8+ characters).</div>';
                return;
            }
            const gate = await screenTextForClassroom(sentence);
            if (!gate.allowed) {
                prewriteFeedback.innerHTML = \`<div class="feedback-error">\${gate.message || "Please rewrite safely."}</div>\`;
                return;
            }
            const usesAction = chosenActionWord && new RegExp(\\\`\\\\b\${chosenActionWord}\\\\b\\\`, 'i').test(sentence);
            if (!usesAction) {
                prewriteFeedback.innerHTML = '<div class="feedback-error">Use your chosen action word to win the mini-battle.</div>';
                return;
            }
            // Victory: award small XP + a gear drop (first win guaranteed Quill)
            const currentQuest = gameState.quests[gameState.currentQuestIndex];
            currentQuest.prewriteCleared = true;
            const bonusXP = 25;
            playerStats.xp += bonusXP;

            // Award gear
            let awarded = null;
            if (!playerStats.inventory["quill_clarity"]) awarded = "quill_clarity";
            else awarded = awardRandomItemId();

            if (awarded) {
                grantItem(awarded);
                showLootModal(awarded, \`Mini-Battle Victory! +\${bonusXP} XP\`);
            } else {
                showMessage(\`Mini-Battle Victory! +\${bonusXP} XP\`);
            }

            // Continue to writing
            hidePanel(prewriteBattle);
            updateQuestLog();
            showWritingChallenge();
        }

        function awardRandomItemId(){
            const unowned = ITEMS.filter(i => !playerStats.inventory[i.id]);
            if (unowned.length === 0) return null;
            return unowned[Math.floor(Math.random()*unowned.length)].id;
        }

        function grantItem(itemId){
            playerStats.inventory[itemId] = { owned:true, equipped:false };
            unlockAchievement("FIRST_GEAR");
            saveGame(true);
        }

        function showLootModal(itemId, headerText="You found gear!") {
            const it = getItem(itemId); if (!it) return;
            document.getElementById('loot-heading').textContent = headerText;
            lootCard.innerHTML = \`
                <div class="flex items-start gap-3">
                    <div class="text-2xl">🎁</div>
                    <div>
                        <div class="flex items-center gap-2">
                            <div class="text-lg font-bold">\${it.name}</div>
                            <span class="slot-badge">\${it.slot}</span>
                        </div>
                        <div class="text-sm text-gray-800">\${it.desc}</div>
                    </div>
                </div>\`;
            lootEquipBtn.onclick = ()=>{ equipItem(itemId); hidePanel(lootPanel); updateQuestLog(); };
            lootCloseBtn.onclick = ()=>{ hidePanel(lootPanel); };
            showPanel(lootPanel);
        }

        // === Gear & Stats ===
        function equipItem(itemId){
            const it = getItem(itemId); if (!it) return;
            // Unequip any existing in slot
            const current = playerStats.equipmentSlots[it.slot];
            if (current && playerStats.inventory[current]) playerStats.inventory[current].equipped = false;
            // Equip new
            playerStats.equipmentSlots[it.slot] = itemId;
            playerStats.inventory[itemId] = playerStats.inventory[itemId] || {owned:true, equipped:false};
            playerStats.inventory[itemId].equipped = true;
            applyGearStats();
            saveGame(true);
        }

        function unequipSlot(slot){
            const current = playerStats.equipmentSlots[slot];
            if (current && playerStats.inventory[current]) playerStats.inventory[current].equipped = false;
            playerStats.equipmentSlots[slot] = null;
            applyGearStats();
            saveGame(true);
        }

        function applyGearStats(){
            // Reset to base (level scaling preserved in levelUpCheck)
            let dmg = 10 + (playerStats.level - 1) * 5; // mirrors levelUpCheck increments
            let hp  = 100 + (playerStats.level - 1) * 20;
            let speedMult = 1.0;
            for (const slot of ["weapon","armor","trinket"]) {
                const id = playerStats.equipmentSlots[slot];
                if (!id) continue;
                const it = getItem(id); if (!it || !it.bonuses) continue;
                if (it.bonuses.damage) dmg += it.bonuses.damage;
                if (it.bonuses.health) hp += it.bonuses.health;
                if (it.bonuses.speed) speedMult += it.bonuses.speed;
            }
            playerStats.baseDamage = Math.max(1, Math.round(dmg));
            playerStats.baseHealth = Math.max(10, Math.round(hp));
            moveSpeed = baseMoveSpeed * speedMult;
            updateQuestLog();
        }

        function renderInventory(){
            equippedReadout.innerHTML = \`
                <div><b>Equipped</b> — Weapon: \${slotName(playerStats.equipmentSlots.weapon)} | Armor: \${slotName(playerStats.equipmentSlots.armor)} | Trinket: \${slotName(playerStats.equipmentSlots.trinket)}</div>
            \`;
            function makeItemRow(it){
                const owned = !!playerStats.inventory[it.id];
                const equipped = owned && playerStats.inventory[it.id].equipped;
                const row = document.createElement('div');
                row.className = 'loot-card';
                row.innerHTML = \`
                    <div class="flex items-start gap-3">
                        <div class="text-2xl">\${owned ? "🧰" : "❔"}</div>
                        <div class="flex-1">
                            <div class="flex items-center gap-2">
                                <div class="font-bold">\${it.name}</div>
                                <span class="slot-badge">\${it.slot}</span>
                                \${equipped ? '<span class="slot-badge">equipped</span>' : ''}
                            </div>
                            <div class="text-sm text-gray-800">\${it.desc}</div>
                        </div>
                        <div>
                            \${owned ? (equipped ? '<button class="text-sm" data-act="unequip">Unequip</button>' : '<button class="text-sm" data-act="equip">Equip</button>') : '<span class="text-sm text-gray-500">Not owned</span>'}
                        </div>
                    </div>\`;
                row.querySelector('[data-act="equip"]')?.addEventListener('click', ()=>{ equipItem(it.id); renderInventory(); });
                row.querySelector('[data-act="unequip"]')?.addEventListener('click', ()=>{ unequipSlot(it.slot); renderInventory(); });
                return row;
            }
            inventoryList.innerHTML = "";
            ITEMS.forEach(it => inventoryList.appendChild(makeItemRow(it)));
        }
        const slotName = (id)=> id ? getItem(id)?.name || '—' : '—';

        // --- MAIN FLOW ---
        function handleInteraction() {
            if (gameState.isCombatActive || !gameState.canInteractWith) return;
            interactPrompt.style.display = 'none';
            if (gameState.canInteractWith.type === 'fragment') {
                const fragment = memoryFragments[gameState.canInteractWith.index];
                if (!fragment.collected) {
                    fragment.collected = true; playerStats.collectedFragments++;
                    const mesh = memoryFragmentMeshes[gameState.canInteractWith.index]; if (mesh) mesh.visible = false;
                    showMessage(fragment.text);
                    if (playerStats.collectedFragments === memoryFragments.length) unlockAchievement("LOREMASTER");
                }
                return;
            }
            const npcName = gameState.canInteractWith;
            const currentQuest = gameState.quests[gameState.currentQuestIndex];
            if (currentQuest && currentQuest.npc === npcName && !currentQuest.isComplete) {
                canMove = false;
                dialogueTitle.textContent = npcName;
                // Gate with mini-battle
                if (currentQuest.type === "writing") {
                    if (!currentQuest.prewriteCleared) {
                        showPrewriteBattle();
                    } else {
                        showWritingChallenge();
                    }
                } else if (currentQuest.type === "writing_combat") {
                    dialogueText.textContent = \`The \${createdMonster.name} threatens the land. Are you ready to face it with your words?\`;
                    dialogueButton.textContent = "I'm Ready";
                    dialogueButton.onclick = () => { hidePanel(dialogueBox); createdMonster.object.visible = true; startWritingCombat(); };
                    showPanel(dialogueBox);
                }
            }
        }

        function showWritingChallenge() {
            const stage = narrativeStages[Math.min(gameState.currentQuestIndex, narrativeStages.length - 1)];
            narrativeStage.textContent = stage;
            const q = gameState.quests[gameState.currentQuestIndex];
            challengeTitle.textContent = \`Challenge: \${q.title}\`;
            challengePrompt.textContent = q.writingPrompt;
            writingInput.value = "";
            feedbackArea.innerHTML = "";
            currentTips.textContent = writingTips[stage];
            writingTipsBox.style.display = 'block';
            writingSubmit.disabled = false; writingSubmit.textContent = "Weave Your Tale";

            // Render action word bank
            renderActionBank(actionWordBank, (w)=> insertWordIntoTextarea(writingInput, w));

            hidePanel(dialogueBox);
            showPanel(writingChallenge, writingInput);
        }

        function insertWordIntoTextarea(textarea, word){
            const start = textarea.selectionStart, end = textarea.selectionEnd;
            const value = textarea.value; const before = value.substring(0,start); const after = value.substring(end);
            const toInsert = (start>0 && !/\\s$/.test(before)) ? " "+word : word;
            textarea.value = before + toInsert + after;
            const pos = (before + toInsert).length; textarea.setSelectionRange(pos,pos); textarea.focus();
        }

        async function submitWriting() {
            const submission = writingInput.value.trim();
            if (submission.length < 20) { showMessage("Your entry is too short. Please write a more detailed description."); return; }
            const gate = await screenTextForClassroom(submission);
            if (!gate.allowed) {
                feedbackArea.textContent = gate.message;
                feedbackArea.className = 'feedback-area feedback-error';
                writingSubmit.disabled = false; writingSubmit.textContent = "Try Again"; return;
            }
            if (gate.nudge) {
                feedbackArea.textContent = \`Tip: \${gate.tip}\`;
                feedbackArea.className = 'feedback-area feedback-success';
            } else { feedbackArea.textContent = ''; feedbackArea.className = 'feedback-area'; }

            writingSubmit.disabled = true; writingSubmit.textContent = "Analyzing...";
            lastSubmission = submission;
            const systemPrompt = \`You are an English teacher evaluating a Year 7 student's story entry. Evaluate it on Clarity, Creativity, and Grammar. Provide one-sentence feedback for each, and a final "Overall Suggestion". The student is writing the "\${narrativeStages[gameState.currentQuestIndex]}" part of their story. The prompt was: "\${gameState.quests[gameState.currentQuestIndex].writingPrompt}"\`;
            const schema = { type:"OBJECT", properties: { validation:{type:"STRING"}, clarity_feedback:{type:"STRING"}, creativity_feedback:{type:"STRING"}, grammar_feedback:{type:"STRING"}, overall_suggestion:{type:"STRING"}, reward_multiplier:{type:"NUMBER"} } };
            const validationResponse = await callGeminiForText(systemPrompt, submission, schema);
            lastValidationResponse = validationResponse;
            if (!validationResponse) { showMessage("There was an error analyzing your writing. Please try again."); writingSubmit.disabled=false; writingSubmit.textContent="Weave Your Tale"; return; }

            if (validationResponse.validation === 'pass') completeQuest();
            else {
                feedbackArea.textContent = validationResponse.overall_suggestion || "This doesn't seem to fit the prompt. Please try rewriting it.";
                feedbackArea.className = 'feedback-area feedback-error';
                writingSubmit.disabled = false; writingSubmit.textContent = "Try Again";
            }
        }

        function completeQuest() {
            const q = gameState.quests[gameState.currentQuestIndex];
            q.isComplete = true;
            const baseXP = q.rewardXP;
            const finalXP = Math.round(baseXP * (lastValidationResponse?.reward_multiplier || 1));
            playerStats.xp += finalXP;
            playerStats.journal.push({ stage: narrativeStages[gameState.currentQuestIndex], title: q.title, text: lastSubmission });
            hidePanel(writingChallenge);
            writingTipsBox.style.display = 'none';
            unlockAchievement("STORY_BEGINS");
            saveGame(true);

            if (gameState.currentQuestIndex === 1) { showDynamicQuestCreator(); changeWorldAtmosphere(lastSubmission); }
            else showQuestComplete(finalXP);

            if (gameState.currentQuestIndex >= gameState.quests.length - 1) unlockAchievement("SAVIOR");
            levelUpCheck(); updateQuestLog();
        }

        function showDynamicQuestCreator() { showPanel(dynamicQuestCreator, dynamicQuestInput); }

        async function submitDynamicQuest() {
            const submission = dynamicQuestInput.value.trim();
            if (submission.length < 20) { showMessage("Please write a more detailed description of what happens next."); return; }
            dynamicQuestSubmit.disabled = true; dynamicQuestSubmit.textContent = "Forging Fate...";
            const gate = await screenTextForClassroom(submission);
            if (!gate.allowed) { showMessage(gate.message); dynamicQuestSubmit.disabled=false; dynamicQuestSubmit.textContent="Shape the Climax"; return; }

            const questData = await callGeminiForQuestGeneration(submission);
            if (questData) {
                const newQuest = { id: "DYNAMIC_CLIMAX", type: questData.quest_type, title: questData.quest_title, objective: questData.objective, writingPrompt: questData.writing_prompt, isComplete: false, npc: questData.npc_to_visit, rewardXP: 250, prewriteCleared:false };
                gameState.quests.splice(2, 0, newQuest);
                if (newQuest.type === 'writing_combat' && questData.monster_name) {
                    currentMonsterName = questData.monster_name; currentMonsterDescription = questData.monster_description;
                    createdMonster.name = currentMonsterName; createdMonster.description = currentMonsterDescription; createdMonster.object.visible = true;
                }
                if (gameState.quests.length === 3) {
                    gameState.quests.push({ id: "FALLING_ACTION", type: "writing", title: "The Aftermath", objective: "Speak to the Sage to reflect on your actions.", writingPrompt: "Describe the immediate consequences of the climax. What changed?", isComplete: false, npc: "Sage of the Tides", rewardXP: 200, prewriteCleared:false });
                    gameState.quests.push({ id: "RESOLUTION", type: "writing", title: "A New Dawn", objective: "Return to the Village Elder to share the final chapter.", writingPrompt: "Describe the scene now. Is the water clear? Are the people hopeful? End the story.", isComplete: false, npc: "Village Elder", rewardXP: 300, prewriteCleared:false });
                }
                playerStats.journal.push({ stage: "Rising Action (cont.)", title: "The Storyteller's Choice", text: submission });
                hidePanel(dynamicQuestCreator); continueToNextQuest();
            } else {
                showMessage("There was an error shaping your story. Please try again.");
                dynamicQuestSubmit.disabled=false; dynamicQuestSubmit.textContent="Shape the Climax";
            }
        }

        async function changeWorldAtmosphere(text) {
            const atmoData = await callGeminiForAtmosphere(text);
            if (atmoData && atmoData.skyColor) {
                startAtmo.sky = scene.background.clone();
                startAtmo.fog = scene.fog.color.clone();
                startAtmo.ground = ground.material.color.clone();
                startAtmo.particles = particleMesh.material.color.clone();
                targetAtmo.sky = new THREE.Color(atmoData.skyColor);
                targetAtmo.fog = new THREE.Color(atmoData.fogColor);
                targetAtmo.ground = new THREE.Color(atmoData.groundColor);
                targetAtmo.particles = new THREE.Color(atmoData.particleColor);
                atmosphereTransitionStart = clock.getElapsedTime(); isTransitioningAtmosphere = true;
            }
        }

        function showQuestComplete(xpGained) {
            rewardText.textContent = \`You earned \${xpGained} XP!\`;
            improvementSuggestion.innerHTML = '';
            if (lastValidationResponse) {
                improvementSuggestion.innerHTML = \`
                    <h3 class="font-bold text-teal-800">Feedback:</h3>
                    <p><strong>Clarity:</strong> \${lastValidationResponse.clarity_feedback || 'Well done.'}</p>
                    <p><strong>Creativity:</strong> \${lastValidationResponse.creativity_feedback || 'Nice ideas.'}</p>
                    <p><strong>Grammar:</strong> \${lastValidationResponse.grammar_feedback || 'Looks good.'}</p>
                    <p class="mt-2"><strong>Suggestion:</strong> \${lastValidationResponse.overall_suggestion || 'Keep it up!'}</p>\`;
            }
            showPanel(questComplete);
        }

        function levelUpCheck() {
            while (playerStats.xp >= playerStats.xpToNextLevel) {
                playerStats.level++; playerStats.xp -= playerStats.xpToNextLevel; playerStats.xpToNextLevel = Math.round(playerStats.xpToNextLevel * 1.5);
                playerStats.baseHealth += 20; playerStats.baseDamage += 5;
                showMessage(\`Congratulations! You've reached Level \${playerStats.level}!\`);
            }
            specialMoveBtn.disabled = playerStats.level < 2;
            applyGearStats();
        }

        function continueToNextQuest() {
            hidePanel(questComplete); hidePanel(monsterCreatedPanel);
            gameState.currentQuestIndex++;
            if (gameState.currentQuestIndex >= gameState.quests.length) { showMessage("You have completed all the quests! The world is safe, for now."); canMove = true; }
            else { updateQuestLog(); canMove = true; }
        }

        function tryAgain() { hidePanel(questComplete); writingInput.value = lastSubmission; feedbackArea.innerHTML = ""; showPanel(writingChallenge); }

        // --- NARRATIVE COMBAT ---
        function startWritingCombat() {
            gameState.isCombatActive = true; canMove = false;
            combatState.playerHP = playerStats.baseHealth; combatState.enemyHP = createdMonster.baseHealth; combatState.isPlayerTurn = true;
            combatTitle.textContent = \`Battle with \${createdMonster.name}!\`;
            combatLog.innerHTML = \`A wild \${createdMonster.name} appears! \${createdMonster.description}.<br>\`;
            updateCombatUI(); nextCombatTurn(); showPanel(combatPanel, combatWritingInput);
        }
        function nextCombatTurn() {
            if (!gameState.isCombatActive) return;
            if (combatState.isPlayerTurn) {
                combatSubmitBtn.disabled=false; combatWritingInput.disabled=false;
                if (combatState.useSpecialMove) { combatPrompt.textContent = "Use a simile to describe your attack!"; combatWritingInput.placeholder = "e.g., My strike is like lightning..."; }
                else { combatPrompt.textContent = "The creature waits. Describe your attack!"; combatWritingInput.placeholder = "e.g., I unleash a torrent of water..."; }
                combatWritingInput.focus();
            } else {
                combatSubmitBtn.disabled=true; combatWritingInput.disabled=true; combatPrompt.textContent = "Enemy is attacking..."; setTimeout(enemyTurn, 1500);
            }
        }
        async function submitCombatWriting() {
            const action = combatWritingInput.value.trim();
            if (action.length < 10) { addToCombatLog("Your description is too short. Be more descriptive to land a solid hit!", "red"); return; }
            const gate = await screenTextForClassroom(action);
            if (!gate.allowed) { addToCombatLog("That move isn’t school-safe. " + (gate.message || "Try a non-graphic description."), "red"); return; }
            if (gate.nudge) addToCombatLog("Tip: " + gate.tip, "green");

            combatSubmitBtn.disabled = true; combatSubmitBtn.textContent = "Analyzing...";
            let systemPrompt = combatState.useSpecialMove
                ? "The player is using a simile in combat. Analyze their sentence. If it's a valid simile, assign damage between 40-60. If not, assign 10 damage. Provide brief, encouraging feedback."
                : "The player is describing an attack. Analyze their sentence for strong verbs, imagery, and creativity. Assign damage between 15-35 based on quality. Provide brief, encouraging feedback.";
            const schema = { type: "OBJECT", properties: { damage: { type: "NUMBER" }, feedback: { type: "STRING" } } };
            const response = await callGeminiForText(systemPrompt, action, schema);
            if (response) {
                const finalDamage = (response.damage || 15) + playerStats.baseDamage;
                combatState.enemyHP -= finalDamage;
                addToCombatLog(\`Your words strike true! (\${response.feedback}) You deal \${finalDamage} damage.\`, "green");
                playerStats.journal.push({ stage: "Combat", title: \`Turn vs \${createdMonster.name}\`, text: action });
                if (combatState.useSpecialMove) unlockAchievement("WORD_WEAVER");
            } else {
                const randomDamage = Math.floor(Math.random()*10) + playerStats.baseDamage;
                combatState.enemyHP -= randomDamage; addToCombatLog(\`Your attack connects! You deal \${randomDamage} damage.\`, "green");
            }
            combatWritingInput.value = ""; combatSubmitBtn.textContent = "Attack!"; combatState.useSpecialMove = false; updateCombatUI();
            if (combatState.enemyHP <= 0) endCombat(true); else { combatState.isPlayerTurn = false; nextCombatTurn(); }
        }
        function enemyTurn() {
            const damage = Math.floor(Math.random()*10) + (playerStats.level * 2);
            combatState.playerHP -= damage; addToCombatLog(\`\${createdMonster.name} retaliates, dealing \${damage} damage!\`, "red");
            updateCombatUI();
            if (combatState.playerHP <= 0) endCombat(false); else { combatState.isPlayerTurn = true; nextCombatTurn(); }
        }
        function addToCombatLog(message, color="black") { combatLog.innerHTML += \`<span style="color:\${color};">\${message}</span><br>\`; combatLog.scrollTop = combatLog.scrollHeight; }
        function updateCombatUI() {
            playerHealthBar.style.width = \`\${Math.max(0, (combatState.playerHP / playerStats.baseHealth) * 100)}%\`;
            enemyHealthBar.style.width = \`\${Math.max(0, (combatState.enemyHP / createdMonster.baseHealth) * 100)}%\`;
        }
        function endCombat(playerWon) {
            gameState.isCombatActive = false; hidePanel(combatPanel);
            if (playerWon) {
                unlockAchievement("FIRST_VICTORY"); const q = gameState.quests[gameState.currentQuestIndex]; q.isComplete = true; playerStats.xp += q.rewardXP;
                hidePanel(combatPanel); showQuestComplete(q.rewardXP); createdMonster.object.visible = false; saveGame(true);
            } else { showMessage("You have been defeated. Rest and try again."); player.position.set(0,0,20); canMove=true; }
            updateQuestLog();
        }

        // --- EVENTS ---
        startGameBtn.addEventListener('click', ()=>{
            const selectedType = guardianTypeOptions.querySelector('.selected');
            const selectedDomain = guardianDomainOptions.querySelector('.selected');
            if (!selectedType || !selectedDomain) { showMessage("Please select a Guardian Type and a Realm."); return; }
            characterData.type = selectedType.dataset.type; characterData.domain = selectedDomain.dataset.domain;
            if (characterData.type === 'custom') {
                const customName = customGuardianInput.value.trim();
                if (customName.length < 3) { showMessage("Please enter a name for your custom guardian."); return; }
                characterData.type = customName;
            }
            hidePanel(characterCreator); uiContainer.style.visibility = 'visible'; canMove = true; gameStarted = true;
            updateQuestLog(); saveGame(true);
        });
        continueGameBtn.addEventListener('click', ()=>{ hidePanel(startModal); loadGame(); });
        newGameBtn.addEventListener('click', ()=>{ hidePanel(startModal); showPanel(characterCreator); });

        guardianTypeOptions.addEventListener('click', e=>{
            const option = e.target.closest('.creator-option'); if (!option) return;
            guardianTypeOptions.querySelectorAll('.selected').forEach(el=>el.classList.remove('selected'));
            option.classList.add('selected'); customGuardianInput.style.display = option.dataset.type === 'custom' ? 'block' : 'none';
        });
        guardianDomainOptions.addEventListener('click', e=>{
            const option = e.target.closest('.creator-option'); if (!option) return;
            guardianDomainOptions.querySelectorAll('.selected').forEach(el=>el.classList.remove('selected'));
            option.classList.add('selected');
        });

        writingSubmit.addEventListener('click', submitWriting);
        dynamicQuestSubmit.addEventListener('click', submitDynamicQuest);
        continueQuestingBtn.addEventListener('click', continueToNextQuest);
        tryAgainBtn.addEventListener('click', tryAgain);
        startCombatBtn.addEventListener('click', ()=>{ hidePanel(monsterCreatedPanel); hidePanel(questComplete); continueToNextQuest(); });
        combatSubmitBtn.addEventListener('click', submitCombatWriting);
        specialMoveBtn.addEventListener('click', ()=>{ combatState.useSpecialMove = true; nextCombatTurn(); });

        openJournalBtn.addEventListener('click', ()=>{
            journalEntries.innerHTML = "";
            playerStats.journal.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'journal-entry';
                entryDiv.innerHTML = \`
                    <h3>\${entry.title}</h3>
                    <p class="journal-stage">\${entry.stage}</p>
                    <p>\${entry.text}</p>
                    <button class="expand-btn">Expand</button>\`;
                journalEntries.appendChild(entryDiv);
            });
            achievementsList.innerHTML = "";
            for (const id in achievements) {
                const ach = achievements[id]; const isUnlocked = playerStats.achievements[id];
                const achDiv = document.createElement('div');
                achDiv.className = isUnlocked ? 'achievement unlocked' : 'achievement locked';
                achDiv.innerHTML = \`<h3>\${ach.title}</h3><p>\${isUnlocked ? ach.description : '??????????'}</p>\`;
                achievementsList.appendChild(achDiv);
            }
            showPanel(journalPanel); canMove = false;
        });
        storyTab.addEventListener('click', ()=>{ storyTab.classList.add('active'); achievementsTab.classList.remove('active'); journalEntries.style.display = 'block'; achievementsList.style.display = 'none'; });
        achievementsTab.addEventListener('click', ()=>{ achievementsTab.classList.add('active'); storyTab.classList.remove('active'); achievementsList.style.display = 'block'; journalEntries.style.display = 'none'; });
        closeJournalBtn.addEventListener('click', ()=>{ hidePanel(journalPanel); canMove = true; });
        copyJournalBtn.addEventListener('click', ()=>{
            const storyText = playerStats.journal.map(e => \`## \${e.title} (\${e.stage})\\n\\n\${e.text}\`).join('\\n\\n---\\n\\n');
            navigator.clipboard.writeText(storyText).then(()=> showMessage("Your story has been copied to the clipboard!")).catch(()=> showMessage("Failed to copy story."));
        });
        journalEntries.addEventListener('click', async (e)=>{
            if (e.target.classList.contains('expand-btn')) {
                const entryDiv = e.target.closest('.journal-entry');
                const originalText = entryDiv.querySelector('p:not(.journal-stage)').textContent;
                e.target.textContent = "Expanding..."; e.target.disabled = true;
                const expandedText = await callGeminiForJournalExpansion(originalText);
                if (expandedText) entryDiv.querySelector('p:not(.journal-stage)').textContent = expandedText;
                e.target.remove();
            }
        });

        // Gear open/close
        openGearBtn.addEventListener('click', ()=>{ renderInventory(); showPanel(gearPanel); canMove=false; });
        closeGearBtn.addEventListener('click', ()=>{ hidePanel(gearPanel); canMove=true; });

        // Mini-battle controls
        prewriteRollBtn.addEventListener('click', shuffleFocus);
        prewriteSubmitBtn.addEventListener('click', resolvePrewriteBattle);

        // Message box
        messageButton.addEventListener('click', ()=>{ hidePanel(messageBox); canMove = true; });

        document.getElementById('minimize-quest-log').addEventListener('click', ()=>{
            questLog.classList.toggle('minimized');
            document.getElementById('minimize-quest-log').textContent = questLog.classList.contains('minimized') ? '+' : '-';
        });

        window.addEventListener('keydown', (event) => {
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) {
                if (event.key === 'Enter' && active.id === 'combat-writing-input') { event.preventDefault(); submitCombatWriting(); }
                return;
            }
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyE': if (!interactKeyPressed) { handleInteraction(); interactKeyPressed = true; } break;
            }
        });
        window.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyE': interactKeyPressed = false; break;
            }
        });

        function showMessage(text) { messageText.textContent = text; showPanel(messageBox, messageButton); canMove = false; }

        function createMemoryFragments() {
            const geom = new THREE.SphereGeometry(0.5, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
            memoryFragments.forEach(f => {
                const mesh = new THREE.Mesh(geom, mat.clone()); mesh.position.copy(f.pos); mesh.userData.baseY = mesh.position.y; scene.add(mesh); memoryFragmentMeshes.push(mesh);
            });
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); const elapsed = clock.getElapsedTime();

            if (isTransitioningAtmosphere) {
                const progress = (elapsed - atmosphereTransitionStart) / (atmosphereTransitionDuration / 1000);
                if (progress < 1) {
                    scene.background.lerpColors(startAtmo.sky, targetAtmo.sky, progress);
                    scene.fog.color.lerpColors(startAtmo.fog, targetAtmo.fog, progress);
                    ground.material.color.lerpColors(startAtmo.ground, targetAtmo.ground, progress);
                    particleMesh.material.color.lerpColors(startAtmo.particles, targetAtmo.particles, progress);
                } else {
                    isTransitioningAtmosphere = false;
                    scene.background.copy(targetAtmo.sky); scene.fog.color.copy(targetAtmo.fog);
                    ground.material.color.copy(targetAtmo.ground); particleMesh.material.color.copy(targetAtmo.particles);
                }
            }

            particleMesh.rotation.y += delta * 0.05;
            memoryFragmentMeshes.forEach(mesh => {
                mesh.rotation.y += delta;
                mesh.position.y = mesh.userData.baseY + Math.sin(elapsed * 2 + mesh.position.x) * 0.25;
            });

            if (!gameStarted) { renderer.render(scene, camera); return; }

            if (canMove) {
                const dir = new THREE.Vector3();
                if (moveForward) dir.z -= 1;
                if (moveBackward) dir.z += 1;
                if (moveLeft) dir.x -= 1;
                if (moveRight) dir.x += 1;
                if (dir.lengthSq() > 0) { dir.normalize().multiplyScalar(moveSpeed * delta); player.position.add(dir); }
            }

            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 50;
            camera.lookAt(player.position);

            // Interactibles
            let closeInteractable = null;
            const npcs = [villageElder, fisherman, sageOfTheTides, warTornElder];
            npcs.forEach(npc => { const d = player.position.distanceTo(npc.position); if (d < 5) closeInteractable = npc.name; });
            memoryFragmentMeshes.forEach((m, i) => { if (m.visible && player.position.distanceTo(m.position) < 2.5) closeInteractable = { type:'fragment', index:i }; });

            if (closeInteractable && !gameState.isCombatActive && canMove) { gameState.canInteractWith = closeInteractable; interactPrompt.style.display = 'block'; }
            else { gameState.canInteractWith = null; interactPrompt.style.display = 'none'; }

            updateNpcNameTags();
            renderer.render(scene, camera);
        }

        function updateNpcNameTags() {
            const npcs = [
                { obj: villageElder, el: document.getElementById('elder-name') },
                { obj: fisherman, el: document.getElementById('fisherman-name') },
                { obj: sageOfTheTides, el: document.getElementById('sage-name') },
                { obj: warTornElder, el: document.getElementById('war-torn-elder-name') },
            ];
            if (!canMove) { npcs.forEach(n=> n.el.style.display='none'); return; }
            npcs.forEach(n => {
                const pos = toScreenPosition(n.obj, camera);
                if (pos) { n.el.style.display='block'; n.el.style.left = \`\${pos.x}px\`; n.el.style.top = \`\${pos.y - 45}px\`; }
                else n.el.style.display='none';
            });
        }

        function toScreenPosition(obj, camera) {
            const v = new THREE.Vector3(); obj.getWorldPosition(v); v.project(camera);
            v.x = (v.x + 1) * window.innerWidth / 2; v.y = -(v.y - 1) * window.innerHeight / 2;
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
            const objDir = new THREE.Vector3().subVectors(obj.position, camera.position);
            if (camDir.dot(objDir) < 0) return null;
            return { x: v.x, y: v.y };
        }

        // --- SAVE/LOAD ---
        function saveGame(isAutoSave=false) {
            try {
                const saveData = {
                    characterData,
                    playerStats,
                    gameState: { currentQuestIndex: gameState.currentQuestIndex, quests: gameState.quests },
                    collectedFragments: memoryFragments.map(f => f.collected)
                };
                localStorage.setItem('narrativeQuestSaveData', JSON.stringify(saveData));
                if (isAutoSave) {
                    const n = document.getElementById('autosave-notification'); n.style.opacity = 1; setTimeout(()=>{ n.style.opacity = 0; }, 1800);
                } else showMessage("Game Saved locally!");
            } catch (e) { console.error("Save error: ", e); if (!isAutoSave) showMessage("Failed to save game."); }
        }
        document.getElementById('save-game-btn').addEventListener('click', ()=> saveGame(false));

        function loadGame() {
            try {
                const savedJSON = localStorage.getItem('narrativeQuestSaveData');
                if (savedJSON) {
                    const saved = JSON.parse(savedJSON);
                    characterData = saved.characterData;
                    playerStats = saved.playerStats;
                    gameState.quests = saved.gameState.quests;
                    gameState.currentQuestIndex = saved.gameState.currentQuestIndex;
                    if (saved.collectedFragments) saved.collectedFragments.forEach((c,i)=>{ if (memoryFragments[i]) { memoryFragments[i].collected = c; if (c) memoryFragmentMeshes[i].visible = false; } });
                    // Re-apply gear stats
                    applyGearStats();
                    hidePanel(characterCreator); uiContainer.style.visibility = 'visible'; canMove = true; gameStarted = true; updateQuestLog(); showMessage("Game Loaded Successfully!");
                } else { showMessage("No local save file found."); showPanel(startModal); }
            } catch (e) { console.error("Load error: ", e); showMessage("Failed to load game. Save may be corrupt. Start a new game."); showPanel(characterCreator); }
        }

        function checkForSavedGame() { return !!localStorage.getItem('narrativeQuestSaveData'); }

        // --- INIT ---
        function main() {
            showPanel(startModal);
            animate();
            const hasSave = checkForSavedGame();
            continueGameBtn.disabled = !hasSave;
        }

        window.onload = function() {
            createMemoryFragments();
            main();
        };

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -viewSize * aspect / 2; camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2; camera.bottom = -viewSize / 2; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
